<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Racing CDI - Control Panel</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", system-ui, sans-serif;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        color: #fff;
        min-height: 100vh;
      }

      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 100;
        text-align: center;
        padding: 5px;
        background: rgba(26, 26, 46, 0.95);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
      }

      .status-bar {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        padding: 6px 10px;
        flex-wrap: wrap;
      }

      .status-indicator {
        padding: 3px 10px;
        border-radius: 12px;
        font-size: 0.75em;
        font-weight: bold;
      }

      .status-connected {
        background: #00c853;
      }
      .status-disconnected {
        background: #ff1744;
      }
      .status-warning {
        background: #ff9100;
      }
      .status-ok {
        background: #00c853;
      }

      .live-display {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .live-item {
        display: flex;
        align-items: center;
        gap: 5px;
        background: rgba(0, 0, 0, 0.4);
        padding: 3px 10px;
        border-radius: 6px;
        border: 1px solid rgba(0, 212, 255, 0.3);
      }

      .live-label {
        font-size: 0.65em;
        color: #888;
        text-transform: uppercase;
      }

      .live-value {
        font-size: 1em;
        font-weight: bold;
        color: #00d4ff;
        font-family: "Courier New", monospace;
      }

      .live-value.warning {
        color: #ff9100;
      }

      .live-value.danger {
        color: #ff4444;
      }

      .port-select {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        font-size: 0.85em;
        min-width: 180px;
      }

      .port-select:focus {
        outline: none;
        border-color: #00d4ff;
      }

      .btn-sm {
        padding: 6px 12px;
        font-size: 0.8em;
      }

      /* Tabs */
      .tabs {
        position: fixed;
        top: 45px;
        left: 0;
        right: 0;
        z-index: 99;
        display: flex;
        background: rgba(22, 33, 62, 0.95);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
      }

      .tab-btn {
        flex: 1;
        padding: 12px 20px;
        background: none;
        border: none;
        color: #888;
        font-size: 0.95em;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        border-bottom: 3px solid transparent;
      }

      .tab-btn:hover {
        color: #fff;
        background: rgba(255, 255, 255, 0.05);
      }

      .tab-btn.active {
        color: #00d4ff;
        border-bottom-color: #00d4ff;
      }

      .tab-content {
        display: none;
        padding: 20px;
        margin-top: 95px;
      }

      .tab-content.active {
        display: block;
      }

      /* Dashboard */
      .dashboard-main {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 15px;
        margin-bottom: 15px;
      }

      .rpm-card {
        background: linear-gradient(
          135deg,
          rgba(0, 255, 136, 0.1) 0%,
          rgba(0, 50, 30, 0.3) 100%
        );
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        border: 1px solid rgba(0, 255, 136, 0.2);
      }

      .rpm-card .gauge-label {
        font-size: 0.9em;
        color: #00ff88;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 5px;
      }

      .rpm-card .gauge-value {
        font-size: 4.5em;
        font-weight: bold;
        color: #00ff88;
        text-shadow: 0 0 40px rgba(0, 255, 136, 0.6);
        line-height: 1;
      }

      .rpm-bar {
        height: 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        margin-top: 15px;
        overflow: hidden;
      }

      .rpm-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff88, #ffff00, #ff4444);
        border-radius: 6px;
        transition: width 0.1s;
      }

      .limiter-indicator {
        display: flex;
        gap: 4px;
        margin-top: 10px;
      }

      .limiter-stage {
        flex: 1;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
      }

      .limiter-stage.active {
        background: #ff4444;
      }
      .limiter-stage:nth-child(1).active {
        background: #ffff00;
      }
      .limiter-stage:nth-child(2).active {
        background: #ff9100;
      }
      .limiter-stage:nth-child(3).active {
        background: #ff5722;
      }
      .limiter-stage:nth-child(4).active {
        background: #ff1744;
      }

      .timing-card {
        background: linear-gradient(
          135deg,
          rgba(0, 212, 255, 0.1) 0%,
          rgba(0, 50, 80, 0.3) 100%
        );
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        border: 1px solid rgba(0, 212, 255, 0.2);
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .timing-card .gauge-label {
        font-size: 0.9em;
        color: #00d4ff;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 5px;
      }

      .timing-card .gauge-value {
        font-size: 3.5em;
        font-weight: bold;
        color: #00d4ff;
        text-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
      }

      .timing-card .gauge-unit {
        font-size: 0.9em;
        color: #666;
        margin-top: 5px;
      }

      .dashboard-gauges {
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 8px;
        margin-bottom: 15px;
      }

      .gauge-card {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        padding: 10px 8px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .gauge-label {
        font-size: 0.7em;
        color: #888;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .gauge-value {
        font-size: 1.5em;
        font-weight: bold;
        color: #00d4ff;
      }

      .gauge-unit {
        font-size: 0.65em;
        color: #555;
        margin-top: 2px;
      }

      /* Dashboard Controls Row */
      .dashboard-controls {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        margin-bottom: 15px;
      }

      .control-panel {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        padding: 15px;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .control-panel h3 {
        color: #00d4ff;
        margin-bottom: 10px;
        font-size: 0.85em;
        text-transform: uppercase;
        letter-spacing: 1px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(0, 212, 255, 0.2);
      }

      .control-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 0;
      }

      .control-label {
        color: #aaa;
        font-size: 0.85em;
      }

      .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        font-size: 0.85em;
        transition: all 0.2s;
      }

      .btn-small {
        padding: 2px 8px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 0.7em;
        background: #444;
        color: #fff;
        margin-left: 8px;
        transition: all 0.2s;
      }
      .btn-small:hover {
        background: #666;
      }
      .btn-small:disabled {
        background: #333;
        color: #666;
        cursor: not-allowed;
      }

      .btn-primary {
        background: #00d4ff;
        color: #000;
      }
      .btn-primary:hover {
        background: #00a8cc;
        transform: scale(1.02);
      }
      .btn-danger {
        background: #ff4444;
        color: #fff;
      }
      .btn-danger:hover {
        background: #cc3333;
      }
      .btn-success {
        background: #00c853;
        color: #fff;
      }
      .btn-success:hover {
        background: #00a040;
      }
      .btn-warning {
        background: #ff9800;
        color: #fff;
      }
      .btn-warning:hover {
        background: #e68900;
      }
      .btn-secondary {
        background: #555;
        color: #fff;
      }
      .btn-secondary:hover {
        background: #666;
      }
      .btn-info {
        background: #17a2b8;
        color: #fff;
      }
      .btn-info:hover {
        background: #138496;
      }

      /* Tombol Ignition */
      .ignition-btn {
        width: 100%;
        padding: 12px 16px;
        font-size: 1.1em;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        border-radius: 8px;
        transition: all 0.3s ease;
      }
      .ignition-btn.active {
        background: #00c853;
        box-shadow: 0 0 15px rgba(0, 200, 83, 0.4);
      }
      .ignition-btn.inactive {
        background: #ff4444;
        box-shadow: 0 0 15px rgba(255, 68, 68, 0.4);
      }
      .ignition-hint {
        text-align: center;
        font-size: 0.75em;
        color: #666;
        margin-top: 5px;
      }

      /* Responsive Dashboard */
      @media (max-width: 900px) {
        .dashboard-main {
          grid-template-columns: 1fr;
        }
        .dashboard-gauges {
          grid-template-columns: repeat(2, 1fr);
        }
        .dashboard-controls {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 500px) {
        .dashboard-gauges {
          grid-template-columns: repeat(2, 1fr);
        }
        .rpm-card .gauge-value {
          font-size: 3em;
        }
        .timing-card .gauge-value {
          font-size: 2.5em;
        }
      }

      /* Realtime Graphs */
      .graphs-section {
        margin-top: 15px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 12px;
        padding: 15px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .graphs-section h3 {
        color: #00d4ff;
        margin-bottom: 12px;
        font-size: 0.85em;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .graphs-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 12px;
      }

      .graph-card {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        padding: 12px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .graph-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .graph-title {
        font-size: 0.75em;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .graph-value {
        font-size: 1em;
        font-weight: bold;
        color: #00d4ff;
      }

      .graph-canvas {
        width: 100%;
        height: 100px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 6px;
      }

      .graph-range {
        display: flex;
        justify-content: space-between;
        font-size: 0.65em;
        color: #555;
        margin-top: 4px;
      }

      /* Oscilloscope Styles (2-column layout) */
      .scope-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 5px;
      }

      .scope-col {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .scope-channel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
      }

      .scope-channel-label {
        font-size: 0.75em;
        font-weight: bold;
        text-transform: uppercase;
      }

      .scope-channel-label.ch1 {
        color: #ffff00;
      }

      .scope-channel-label.ch2 {
        color: #00ffff;
      }

      .scope-channel-info {
        font-size: 0.7em;
        color: #888;
        font-family: "Courier New", monospace;
      }

      .scope-canvas-container {
        position: relative;
      }

      .scope-canvas {
        width: 100%;
        height: 80px;
        background: #0a0a0a;
        border-radius: 4px;
        border: 1px solid #333;
      }

      .scope-axis-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 10px;
      }

      .scope-axis {
        display: flex;
        justify-content: space-between;
        padding: 2px 8px;
        font-size: 0.65em;
        color: #555;
      }

      .scope-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 10px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px 8px 0 0;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-bottom: none;
        margin-top: 10px;
      }

      .scope-title {
        font-size: 0.8em;
        font-weight: bold;
        color: #00ff88;
        letter-spacing: 1px;
      }

      @media (max-width: 600px) {
        .scope-row {
          grid-template-columns: 1fr;
        }
        .scope-axis-row {
          grid-template-columns: 1fr;
        }
      }

      .btn-group {
        display: flex;
        gap: 8px;
      }

      .map-selector {
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 6px;
      }

      .map-btn {
        padding: 10px 0;
        border-radius: 6px;
        border: 2px solid #333;
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        font-size: 1em;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
      }

      .map-btn.active {
        border-color: #00d4ff;
        background: rgba(0, 212, 255, 0.2);
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.4);
      }

      .map-btn:hover {
        transform: scale(1.03);
        border-color: #555;
      }

      .flags {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }

      .flag {
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 0.65em;
        font-weight: bold;
        background: rgba(255, 255, 255, 0.08);
        color: #555;
        text-transform: uppercase;
      }

      .flag.active {
        background: #ff4444;
        color: #fff;
      }
      .flag.active.ok {
        background: #00c853;
      }

      /* Config source indicator */
      .flag.config-source {
        background: rgba(0, 212, 255, 0.2);
        color: #00d4ff;
      }
      .flag.config-source.cfg-sd {
        background: rgba(0, 200, 83, 0.25);
        color: #00c853;
      }
      .flag.config-source.cfg-flash {
        background: rgba(255, 193, 7, 0.25);
        color: #ffc107;
      }
      .flag.config-source.cfg-hardcoded {
        background: rgba(255, 68, 68, 0.25);
        color: #ff6b6b;
      }

      .info-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .info-item {
        background: rgba(0, 0, 0, 0.2);
        padding: 8px 12px;
        border-radius: 6px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .info-label {
        color: #888;
        font-size: 0.85em;
      }

      .info-value {
        color: #00d4ff;
        font-weight: bold;
        font-size: 0.9em;
      }

      /* Log Panel */
      .log-panel {
        background: rgba(255, 255, 255, 0.03);
        border-radius: 12px;
        padding: 15px;
        margin-top: 15px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .log-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap;
        gap: 8px;
      }

      .log-header h3 {
        color: #00d4ff;
        margin: 0;
        font-size: 0.85em;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .log-controls {
        display: flex;
        gap: 6px;
        align-items: center;
      }

      .log-select {
        padding: 5px 10px;
        border-radius: 5px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        font-size: 0.8em;
        min-width: 120px;
      }

      .log-info {
        display: flex;
        justify-content: space-between;
        padding: 5px 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        margin-bottom: 8px;
        font-size: 0.8em;
      }

      .log-info span:first-child {
        color: #00d4ff;
      }

      .log-size {
        color: #888;
      }

      .log-table-container {
        max-height: 250px;
        overflow-y: auto;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.2);
      }

      .log-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8em;
      }

      .log-table th {
        background: rgba(0, 212, 255, 0.2);
        color: #00d4ff;
        padding: 8px 6px;
        text-align: center;
        position: sticky;
        top: 0;
        font-size: 0.85em;
      }

      .log-table td {
        padding: 6px;
        text-align: center;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .log-table tr:hover td {
        background: rgba(255, 255, 255, 0.05);
      }

      .log-empty {
        color: #666;
        padding: 30px !important;
      }

      .log-stats {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 6px;
        font-size: 0.85em;
        flex-wrap: wrap;
      }

      .log-stat {
        display: flex;
        gap: 6px;
      }

      .log-stat-label {
        color: #888;
      }

      .log-stat-value {
        color: #00d4ff;
        font-weight: bold;
      }

      /* Map Editor */
      .map-toolbar {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 10px;
        margin-bottom: 15px;
        position: sticky;
        top: 0;
        z-index: 10;
        flex-wrap: wrap;
      }

      .map-tabs {
        display: flex;
        gap: 4px;
      }

      .map-tab {
        padding: 6px 12px;
        border: 2px solid #333;
        background: rgba(0, 0, 0, 0.3);
        color: #666;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        font-size: 0.85em;
        transition: all 0.2s;
      }

      .map-tab.active {
        border-color: #00d4ff;
        color: #00d4ff;
        background: rgba(0, 212, 255, 0.15);
      }

      .map-tab:hover:not(.active) {
        color: #aaa;
        border-color: #555;
      }

      .map-actions {
        display: flex;
        gap: 8px;
        margin-left: auto;
      }

      .map-canvas-container {
        background: linear-gradient(
          135deg,
          rgba(0, 0, 0, 0.4) 0%,
          rgba(0, 0, 0, 0.2) 100%
        );
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 15px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #mapCanvas {
        width: 100%;
        height: 280px;
        background: #0a0a0a;
        border-radius: 8px;
        cursor: crosshair;
      }

      .map-table-container {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 12px;
        padding: 15px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .map-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85em;
      }

      .map-table thead th {
        background: rgba(0, 212, 255, 0.2);
        color: #00d4ff;
        font-size: 0.75em;
        padding: 8px 4px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .map-table tbody th {
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
        font-size: 0.8em;
        font-weight: bold;
        padding: 6px 8px;
        text-align: right;
        border: 1px solid rgba(255, 255, 255, 0.1);
        min-width: 50px;
      }

      .map-table td {
        padding: 4px;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.05);
        vertical-align: middle;
      }

      .map-cell {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        gap: 4px;
      }

      .map-cell .rpm-label {
        font-size: 0.65em;
        color: #00d4ff;
        font-weight: bold;
        white-space: nowrap;
        min-width: 28px;
        text-align: right;
      }

      .map-table input {
        width: 42px;
        padding: 6px 2px;
        border: none;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        text-align: center;
        font-size: 0.85em;
        transition: all 0.15s;
      }

      .map-table input:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .map-table input:focus {
        outline: none;
        background: rgba(0, 212, 255, 0.3);
        box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.4);
      }

      .map-table input.changed {
        background: rgba(255, 100, 100, 0.4);
      }

      .map-quick-edit {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 15px;
        margin-top: 15px;
      }

      .quick-edit-card {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        padding: 15px;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .quick-edit-card h4 {
        color: #00d4ff;
        font-size: 0.85em;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .quick-edit-row {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      /* Settings */
      .settings-toolbar {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        padding: 15px;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 10px;
        margin-bottom: 20px;
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 20px;
      }

      .settings-section {
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.08) 0%,
          rgba(255, 255, 255, 0.03) 100%
        );
        border-radius: 12px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .settings-section h3 {
        color: #00d4ff;
        margin-bottom: 15px;
        font-size: 0.95em;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        padding-bottom: 10px;
        border-bottom: 2px solid rgba(0, 212, 255, 0.3);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .settings-section h3::before {
        content: "";
        width: 4px;
        height: 16px;
        background: #00d4ff;
        border-radius: 2px;
      }

      .setting-row {
        display: grid;
        grid-template-columns: 1fr auto auto;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
        padding: 10px 12px;
        background: rgba(0, 0, 0, 0.25);
        border-radius: 8px;
        transition: background 0.2s;
      }

      .setting-row:hover {
        background: rgba(0, 0, 0, 0.35);
      }

      .setting-label {
        color: #ccc;
        font-size: 0.88em;
      }

      .setting-input {
        width: 90px;
        padding: 8px 10px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.4);
        color: #fff;
        text-align: right;
        font-size: 0.9em;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      .setting-input:focus {
        outline: none;
        border-color: #00d4ff;
        box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
      }

      .setting-select {
        padding: 8px 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.4);
        color: #fff;
        font-size: 0.9em;
        cursor: pointer;
      }

      .setting-select:focus {
        outline: none;
        border-color: #00d4ff;
      }

      .setting-unit {
        color: #666;
        font-size: 0.75em;
        min-width: 80px;
      }

      /* Console (embedded in Files tab) */
      .console-panel {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.3);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .console-title {
        color: #00d4ff;
        font-weight: bold;
        font-size: 0.85em;
      }

      .console-actions {
        display: flex;
        gap: 8px;
      }

      .console {
        background: transparent;
        padding: 10px;
        font-family: monospace;
        font-size: 0.8em;
        flex: 1;
        overflow-y: auto;
        min-height: 150px;
        max-height: 200px;
      }

      .console-line {
        margin-bottom: 2px;
        word-break: break-all;
        line-height: 1.4;
      }

      .console-line.cmd {
        color: #00d4ff;
      }
      .console-line.resp {
        color: #888;
      }
      .console-line.err {
        color: #ff4444;
      }

      .console-input {
        display: flex;
        gap: 8px;
        padding: 8px 10px;
        background: rgba(0, 0, 0, 0.2);
        border-top: 1px solid rgba(255, 255, 255, 0.05);
      }

      .console-input input {
        flex: 1;
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.08);
        color: #fff;
        font-family: monospace;
        font-size: 0.85em;
      }

      .console-input input:focus {
        outline: 1px solid #00d4ff;
        background: rgba(255, 255, 255, 0.12);
      }

      .console-input input::placeholder {
        color: #555;
      }

      /* Toast notification */
      .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        color: #fff;
        font-weight: bold;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s;
        z-index: 1000;
      }

      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }

      .toast.success {
        background: #00c853;
      }
      .toast.error {
        background: #ff4444;
      }
      .toast.info {
        background: #00d4ff;
        color: #000;
      }

      /* Files Tab - Two Column Layout */
      .files-container {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 15px;
        height: calc(100vh - 200px);
        min-height: 500px;
      }

      .files-main {
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .files-sidebar {
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-height: 0;
      }

      .files-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .files-toolbar {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }

      .files-toolbar .btn {
        padding: 6px 10px;
        font-size: 0.8em;
      }

      .current-path {
        font-family: monospace;
        background: rgba(0, 0, 0, 0.4);
        padding: 5px 10px;
        border-radius: 4px;
        color: #00d4ff;
        font-size: 0.85em;
      }

      .disk-info {
        background: rgba(0, 0, 0, 0.4);
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 0.8em;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .disk-label {
        color: #666;
      }

      .file-list {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        flex: 1;
        overflow-y: auto;
        min-height: 0;
      }

      .file-item {
        display: flex;
        align-items: center;
        padding: 10px 12px;
        cursor: pointer;
        transition: all 0.15s;
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      }

      .file-item:last-child {
        border-bottom: none;
      }

      .file-item:hover {
        background: rgba(255, 255, 255, 0.08);
      }

      .file-item.selected {
        background: rgba(0, 212, 255, 0.15);
        border-left: 3px solid #00d4ff;
      }

      .file-item.directory {
        color: #00d4ff;
      }

      .file-item.directory:hover {
        background: rgba(0, 212, 255, 0.1);
      }

      .file-item.file {
        color: #ddd;
      }

      .file-item .file-icon {
        width: 28px;
        font-size: 1em;
        opacity: 0.7;
      }

      .file-item .file-name {
        flex: 1;
        font-size: 0.9em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .file-item .file-size {
        color: #666;
        font-size: 0.75em;
        margin-left: 10px;
        min-width: 60px;
        text-align: right;
      }

      .file-item .file-actions {
        display: flex;
        gap: 4px;
        margin-left: 8px;
        opacity: 0;
        transition: opacity 0.15s;
      }

      .file-item:hover .file-actions {
        opacity: 1;
      }

      .file-item .file-actions .btn {
        padding: 3px 8px;
        font-size: 0.7em;
      }

      .file-loading {
        color: #666;
        text-align: center;
        padding: 40px;
        font-size: 0.9em;
      }

      .file-empty {
        color: #555;
        text-align: center;
        padding: 40px;
        font-size: 0.85em;
      }

      /* File Viewer */
      .file-viewer {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 8px;
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
        margin-top: 12px;
      }

      .file-viewer-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.3);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .file-viewer-header .viewer-filename {
        flex: 1;
        font-weight: bold;
        color: #00d4ff;
        font-size: 0.85em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .file-viewer-header .file-size {
        color: #666;
        font-size: 0.75em;
      }

      .file-viewer-header .btn {
        padding: 4px 10px;
        font-size: 0.75em;
      }

      .file-content {
        padding: 12px;
        flex: 1;
        overflow: auto;
        font-family: monospace;
        font-size: 0.8em;
        color: #aaa;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin: 0;
        line-height: 1.5;
        min-height: 0;
      }

      .file-viewer-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px;
        color: #444;
        text-align: center;
      }

      .file-viewer-empty .icon {
        font-size: 2.5em;
        margin-bottom: 10px;
        opacity: 0.5;
      }

      /* Quick Actions Panel */
      .quick-actions {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 12px;
      }

      .quick-actions-title {
        color: #888;
        font-size: 0.75em;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 10px;
      }

      .quick-actions-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .quick-actions-grid .btn {
        padding: 8px;
        font-size: 0.8em;
      }

      /* Responsive */
      @media (max-width: 900px) {
        .files-container {
          grid-template-columns: 1fr;
          height: auto;
        }

        .files-sidebar {
          order: -1;
        }

        .console {
          max-height: 150px;
        }
      }

      /* Quick Shifter Map */
      .qs-map-section {
        margin-top: 20px;
        background: rgba(255, 200, 0, 0.05);
        border: 1px solid rgba(255, 200, 0, 0.2);
        border-radius: 12px;
        padding: 15px;
      }

      .qs-map-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
      }

      .qs-map-header h4 {
        color: #ffc800;
        margin: 0;
        font-size: 1em;
      }

      .qs-map-actions {
        display: flex;
        gap: 8px;
      }

      .qs-map-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 8px;
      }

      .qs-map-cell {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 8px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .qs-map-cell .rpm-label {
        color: #00d4ff;
        font-size: 0.7em;
        font-weight: bold;
        margin-bottom: 4px;
      }

      .qs-map-cell input {
        width: 50px;
        padding: 5px;
        border: none;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        text-align: center;
        font-size: 0.85em;
      }

      .qs-map-cell input:focus {
        outline: none;
        background: rgba(255, 200, 0, 0.3);
        box-shadow: 0 0 0 2px rgba(255, 200, 0, 0.4);
      }

      .qs-map-cell input.changed {
        background: rgba(255, 100, 100, 0.4);
      }

      .qs-map-cell .unit {
        color: #888;
        font-size: 0.7em;
        margin-top: 2px;
      }

      @media (max-width: 600px) {
        .rpm-gauge {
          grid-column: span 1;
        }
        .rpm-gauge .gauge-value {
          font-size: 3em;
        }
        .gauge-value {
          font-size: 2em;
        }

        .qs-map-grid {
          grid-template-columns: repeat(3, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="status-bar">
        <span id="connStatus" class="status-indicator status-disconnected"
          >DISCONNECTED</span
        >
        <div class="live-display">
          <div class="live-item">
            <span class="live-label">RPM</span>
            <span class="live-value" id="liveRpm">0</span>
          </div>
          <div class="live-item">
            <span class="live-label">TIMING</span>
            <span class="live-value" id="liveTiming">0Â°</span>
          </div>
        </div>
        <span id="engineStatus" class="status-indicator status-warning"
          >ENGINE OFF</span
        >
        <span id="mapStatus" class="status-indicator status-ok">MAP 1</span>
      </div>
    </div>

    <div class="tabs">
      <button class="tab-btn active" data-tab="dashboard">Dashboard</button>
      <button class="tab-btn" data-tab="maps">Map Editor</button>
      <button class="tab-btn" data-tab="settings">Settings</button>
      <button class="tab-btn" data-tab="files">Files & Console</button>
    </div>

    <!-- Dashboard Tab -->
    <div id="dashboard" class="tab-content active">
      <!-- Main Gauges: RPM + Timing -->
      <div class="dashboard-main">
        <div class="rpm-card">
          <div class="gauge-label">RPM</div>
          <div class="gauge-value" id="rpmValue">0</div>
          <div class="rpm-bar">
            <div class="rpm-bar-fill" id="rpmBar" style="width: 0%"></div>
          </div>
          <div class="limiter-indicator">
            <div class="limiter-stage" id="lim1"></div>
            <div class="limiter-stage" id="lim2"></div>
            <div class="limiter-stage" id="lim3"></div>
            <div class="limiter-stage" id="lim4"></div>
          </div>
        </div>
        <div class="timing-card">
          <div class="gauge-label">Timing</div>
          <div class="gauge-value" id="timingValue">0</div>
          <div class="gauge-unit">Â° BTDC</div>
        </div>
      </div>

      <!-- Secondary Gauges -->
      <div class="dashboard-gauges">
        <div class="gauge-card">
          <div class="gauge-label">Temperature</div>
          <div class="gauge-value" id="tempValue">0</div>
          <div class="gauge-unit">Â°C</div>
        </div>
        <div class="gauge-card">
          <div class="gauge-label">Battery</div>
          <div class="gauge-value" id="battValue">0.0</div>
          <div class="gauge-unit">V</div>
        </div>
        <div class="gauge-card">
          <div class="gauge-label">Charging</div>
          <div class="gauge-value" id="chargingValue">0.0</div>
          <div class="gauge-unit">V</div>
        </div>
        <div class="gauge-card">
          <div class="gauge-label">Peak RPM</div>
          <div class="gauge-value" id="peakValue">0</div>
          <div class="gauge-unit">max</div>
        </div>
        <div class="gauge-card">
          <div class="gauge-label">dRPM</div>
          <div class="gauge-value" id="dRpmValue">0</div>
          <div class="gauge-unit">/cycle</div>
        </div>
        <div class="gauge-card">
          <div class="gauge-label">Phase</div>
          <div class="gauge-value" id="phaseCorrValue">0</div>
          <div class="gauge-unit">ticks</div>
        </div>
      </div>

      <!-- Controls Row -->
      <div class="dashboard-controls">
        <div class="control-panel">
          <h3>Map Select</h3>
          <div class="map-selector">
            <button class="map-btn" data-map="1">1</button>
            <button class="map-btn" data-map="2">2</button>
            <button class="map-btn" data-map="3">3</button>
            <button class="map-btn" data-map="4">4</button>
            <button class="map-btn" data-map="5">5</button>
            <button class="map-btn" data-map="6">6</button>
          </div>
        </div>

        <div class="control-panel">
          <h3>Status</h3>
          <div class="flags">
            <span class="flag" id="flagEngine">ENGINE</span>
            <span class="flag" id="flagOverheat">OVERHEAT</span>
            <span class="flag" id="flagLowBatt">LOW BATT</span>
            <span class="flag" id="flagKill">KILL SW</span>
            <span class="flag" id="flagSdOk">SD OK</span>
            <span class="flag config-source" id="flagConfigSource"
              >CFG: SD</span
            >
          </div>
        </div>

        <div class="control-panel">
          <h3>Ignition Control</h3>
          <button
            id="btnIgnition"
            class="btn btn-success ignition-btn"
            onclick="toggleIgnition()"
          >
            <span id="ignitionLabel">AKTIF</span>
          </button>
          <p class="ignition-hint" id="ignitionHint">
            Klik untuk matikan pengapian
          </p>
          <button
            class="btn btn-danger btn-sm"
            style="margin-top: 10px; width: 100%"
            onclick="confirmResetPeak()"
          >
            Reset Peak RPM
          </button>
        </div>
      </div>

      <!-- Realtime Graphs -->
      <div class="graphs-section">
        <h3>REALTIME GRAPHS</h3>
        <div class="graphs-grid">
          <div class="graph-card">
            <div class="graph-header">
              <span class="graph-title">RPM</span>
              <span class="graph-value" id="graphRpmValue">0</span>
            </div>
            <canvas id="graphRpm" class="graph-canvas"></canvas>
            <div class="graph-range">
              <span>0</span>
              <span>15000</span>
            </div>
          </div>

          <div class="graph-card">
            <div class="graph-header">
              <span class="graph-title">Temperature</span>
              <span class="graph-value" id="graphTempValue">0Â°C</span>
            </div>
            <canvas id="graphTemp" class="graph-canvas"></canvas>
            <div class="graph-range">
              <span>0Â°C</span>
              <span>200Â°C</span>
            </div>
          </div>

          <div class="graph-card">
            <div class="graph-header">
              <span class="graph-title">Battery</span>
              <span class="graph-value" id="graphBattValue">0.0V</span>
            </div>
            <canvas id="graphBatt" class="graph-canvas"></canvas>
            <div class="graph-range">
              <span>8V</span>
              <span>16V</span>
            </div>
          </div>

          <div class="graph-card">
            <div class="graph-header">
              <span class="graph-title">Charging</span>
              <span class="graph-value" id="graphChargingValue">0.0V</span>
            </div>
            <canvas id="graphCharging" class="graph-canvas"></canvas>
            <div class="graph-range">
              <span>8V</span>
              <span>16V</span>
            </div>
          </div>

          <div class="graph-card">
            <div class="graph-header">
              <span class="graph-title">CPU Usage</span>
              <span class="graph-value" id="graphCpuValue">0%</span>
            </div>
            <canvas id="graphCpu" class="graph-canvas"></canvas>
            <div class="graph-range">
              <span>0%</span>
              <span>100%</span>
            </div>
          </div>

          <div class="graph-card">
            <div class="graph-header">
              <span class="graph-title">RAM Usage</span>
              <span class="graph-value" id="graphRamValue">0%</span>
            </div>
            <canvas id="graphRam" class="graph-canvas"></canvas>
            <div class="graph-range">
              <span>0%</span>
              <span>100%</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Data Log Panel -->
      <div class="log-panel">
        <div class="log-header">
          <h3>DATA LOG</h3>
          <div class="log-controls">
            <select
              id="logFileSelect"
              class="log-select"
              onchange="loadSelectedLog()"
            >
              <option value="">-- Select Log --</option>
            </select>
            <button class="btn btn-secondary btn-sm" onclick="refreshLogList()">
              Refresh
            </button>
            <button class="btn btn-primary btn-sm" onclick="loadLatestLog()">
              Latest
            </button>
          </div>
        </div>
        <div class="log-info">
          <span id="logFileName">No log loaded</span>
          <span id="logFileSize" class="log-size"></span>
        </div>
        <div class="log-table-container">
          <table class="log-table" id="logTable">
            <thead>
              <tr>
                <th>Time</th>
                <th>RPM</th>
                <th>Timing</th>
                <th>Temp</th>
                <th>Batt</th>
                <th>Map</th>
                <th>Lim</th>
              </tr>
            </thead>
            <tbody id="logTableBody">
              <tr>
                <td colspan="7" class="log-empty">
                  Click "Latest" or select a log file
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="log-stats" id="logStats"></div>
      </div>
    </div>

    <!-- Map Editor Tab -->
    <div id="maps" class="tab-content">
      <!-- Toolbar -->
      <div class="map-toolbar">
        <div class="map-tabs">
          <button class="map-tab active" data-mapnum="1">1</button>
          <button class="map-tab" data-mapnum="2">2</button>
          <button class="map-tab" data-mapnum="3">3</button>
          <button class="map-tab" data-mapnum="4">4</button>
          <button class="map-tab" data-mapnum="5">5</button>
          <button class="map-tab" data-mapnum="6">6</button>
        </div>
        <button class="btn btn-danger btn-sm" onclick="setActiveMap()">
          â˜… Active
        </button>
        <div class="map-actions">
          <button class="btn btn-primary btn-sm" onclick="loadCurrentMap()">
            â†“ Load
          </button>
          <button class="btn btn-success btn-sm" onclick="uploadCurrentMap()">
            â†‘ Upload
          </button>
          <button class="btn btn-warning btn-sm" onclick="saveToSD()">
            ðŸ’¾ Save SD
          </button>
          <button class="btn btn-secondary btn-sm" onclick="copyMap()">
            Copy
          </button>
          <button class="btn btn-secondary btn-sm" onclick="pasteMap()">
            Paste
          </button>
          <span style="border-left: 1px solid #444; margin: 0 8px"></span>
          <button
            class="btn btn-info btn-sm"
            onclick="confirmLoadMap()"
            title="Load safety map from Flash"
          >
            â†“ Flash
          </button>
          <button
            class="btn btn-secondary btn-sm"
            onclick="confirmSaveMap()"
            title="Save current map to Flash as safety backup"
          >
            â˜… Flash
          </button>
        </div>
      </div>
      <div style="text-align: center; margin-bottom: 8px; font-size: 12px">
        <span id="mapDataSource" style="color: #888"
          >ðŸ“‚ Data displayed from: <b>--</b></span
        >
      </div>

      <!-- Oscilloscope Header -->
      <div class="scope-toolbar">
        <span class="scope-title">OSCILLOSCOPE</span>
        <button
          id="btnIgnition2"
          class="btn btn-success btn-sm"
          onclick="toggleIgnition()"
          title="Toggle Ignition"
        >
          IGN ON
        </button>
      </div>

      <!-- Oscilloscope (2 columns) -->
      <div class="scope-row">
        <div class="scope-col">
          <div class="scope-channel-header">
            <span class="scope-channel-label ch1">CH1: VR INPUT</span>
            <span class="scope-channel-info" id="scopeCh1Info"
              >Trigger @ 0Â° BTDC</span
            >
          </div>
          <div class="scope-canvas-container">
            <canvas id="scopeCh1" class="scope-canvas"></canvas>
          </div>
        </div>
        <div class="scope-col">
          <div class="scope-channel-header">
            <span class="scope-channel-label ch2">CH2: IGN OUT</span>
            <span class="scope-channel-info" id="scopeCh2Info"
              >Fire @ 0Â° | CUT: NO</span
            >
          </div>
          <div class="scope-canvas-container">
            <canvas id="scopeCh2" class="scope-canvas"></canvas>
          </div>
        </div>
      </div>
      <div class="scope-axis-row">
        <div class="scope-axis" id="scopeAxis1"></div>
        <div class="scope-axis" id="scopeAxis2"></div>
      </div>

      <!-- Graph -->
      <div class="map-canvas-container">
        <canvas id="mapCanvas"></canvas>
      </div>

      <!-- Table Grid 9x9 -->
      <div class="map-table-container">
        <table class="map-table" id="mapTable"></table>
      </div>

      <!-- Quick Edit -->
      <div class="map-quick-edit">
        <div class="quick-edit-card">
          <h4>Adjust All</h4>
          <div class="quick-edit-row">
            <button
              class="btn btn-secondary btn-sm"
              onclick="adjustAllTiming(-5)"
            >
              -5Â°
            </button>
            <button
              class="btn btn-secondary btn-sm"
              onclick="adjustAllTiming(-1)"
            >
              -1Â°
            </button>
            <button
              class="btn btn-secondary btn-sm"
              onclick="adjustAllTiming(1)"
            >
              +1Â°
            </button>
            <button
              class="btn btn-secondary btn-sm"
              onclick="adjustAllTiming(5)"
            >
              +5Â°
            </button>
          </div>
        </div>
        <div class="quick-edit-card">
          <h4>Set Range</h4>
          <div class="quick-edit-row">
            <input
              type="number"
              id="rangeStart"
              placeholder="From"
              class="setting-input"
              style="width: 70px"
            />
            <span style="color: #666">â†’</span>
            <input
              type="number"
              id="rangeEnd"
              placeholder="To"
              class="setting-input"
              style="width: 70px"
            />
            <input
              type="number"
              id="rangeValue"
              placeholder="Â°"
              class="setting-input"
              style="width: 50px"
            />
            <button class="btn btn-primary btn-sm" onclick="setRange()">
              Set
            </button>
          </div>
        </div>
      </div>

      <!-- Quick Shifter Map -->
      <div class="qs-map-section" id="qsMapSection">
        <div class="qs-map-header">
          <h4>âš¡ Quick Shifter Cut Time Map (RPM â†’ ms)</h4>
          <div class="qs-map-actions">
            <button class="btn btn-primary btn-sm" onclick="loadQsMap()">
              â†“ Load
            </button>
            <button class="btn btn-success btn-sm" onclick="uploadQsMap()">
              â†‘ Upload
            </button>
            <button class="btn btn-warning btn-sm" onclick="saveToSD()">
              ðŸ’¾ SD
            </button>
            <span style="border-left: 1px solid #664; margin: 0 6px"></span>
            <button
              class="btn btn-info btn-sm"
              onclick="confirmLoadQS()"
              title="Load QS from Flash"
            >
              â†“ Flash
            </button>
            <button
              class="btn btn-secondary btn-sm"
              onclick="confirmSaveQS()"
              title="Save QS to Flash"
            >
              â˜… Flash
            </button>
          </div>
        </div>
        <div style="text-align: center; margin-bottom: 8px; font-size: 11px">
          <span id="qsDataSource" style="color: #888"
            >ðŸ“‚ Data displayed from: <b>--</b></span
          >
        </div>
        <div class="qs-map-grid" id="qsMapGrid">
          <!-- Generated by JS -->
        </div>
      </div>
    </div>

    <!-- Settings Tab -->
    <div id="settings" class="tab-content">
      <!-- Toolbar -->
      <div class="settings-toolbar">
        <select id="portSelect" class="setting-select" style="min-width: 180px">
          <option value="">-- Select Port --</option>
        </select>
        <button id="btnConnect" class="btn btn-success" onclick="connectPort()">
          Connect
        </button>
        <button
          id="btnDisconnect"
          class="btn btn-danger"
          onclick="disconnectPort()"
          style="display: none"
        >
          Disconnect
        </button>
        <button class="btn btn-secondary" onclick="refreshPorts()">
          â†» Refresh
        </button>
        <div style="flex-grow: 1"></div>
        <button class="btn btn-primary" onclick="loadAllSettings()">
          â†“ Load
        </button>
        <button class="btn btn-success" onclick="saveAllSettings()">
          â†‘ Apply
        </button>
        <button class="btn btn-warning" onclick="saveToSD()">ðŸ’¾ Save SD</button>
        <span style="border-left: 1px solid #444; margin: 0 8px"></span>
        <button
          class="btn btn-info btn-sm"
          onclick="confirmLoadSettings()"
          title="Load settings from Flash"
        >
          â†“ Flash
        </button>
        <button
          class="btn btn-secondary btn-sm"
          onclick="confirmSaveSettings()"
          title="Save settings to Flash"
        >
          â˜… Flash
        </button>
      </div>
      <div style="text-align: center; margin-bottom: 6px; font-size: 12px">
        <span id="settingsDataSource" style="color: #888"
          >ðŸ“‚ Data displayed from: <b>--</b></span
        >
      </div>
      <div
        style="
          text-align: center;
          margin-bottom: 10px;
          font-size: 11px;
          color: #666;
        "
      >
        <span id="configSourceSettings" style="margin-right: 10px"
          >Boot config: --</span
        >
        <span style="color: #444">|</span>
        <span id="defaultsStatus" style="margin-left: 10px"
          >Flash: Loading...</span
        >
      </div>

      <div class="settings-grid">
        <!-- Engine & Trigger -->
        <div class="settings-section">
          <h3>Engine & Trigger</h3>
          <div class="setting-row">
            <span class="setting-label">Engine Type</span>
            <select id="setEngineType" class="setting-select">
              <option value="2">2-Stroke</option>
              <option value="4">4-Stroke</option>
            </select>
            <span class="setting-unit"></span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Trigger Angle</span>
            <input
              type="number"
              id="setTriggerAngle"
              class="setting-input"
              step="0.1"
            />
            <span class="setting-unit">Â° BTDC</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Trigger Edge</span>
            <select id="setTriggerEdge" class="setting-select">
              <option value="RISING">Rising</option>
              <option value="FALLING">Falling</option>
            </select>
            <span class="setting-unit"></span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Noise Filter</span>
            <input type="number" id="setNoiseFilter" class="setting-input" />
            <span class="setting-unit">Âµs</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">CDI Pulse Width</span>
            <input
              type="number"
              id="setCdiPulse"
              class="setting-input"
              min="50"
              max="250"
              step="10"
            />
            <span class="setting-unit">Âµs</span>
          </div>
        </div>

        <!-- Rev Limiter -->
        <div class="settings-section">
          <h3>Rev Limiter</h3>
          <div class="setting-row">
            <span class="setting-label">Soft Limit (Retard)</span>
            <input
              type="number"
              id="setLimiterSoft"
              class="setting-input"
              step="100"
            />
            <span class="setting-unit">RPM</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Medium (50% Cut)</span>
            <input
              type="number"
              id="setLimiterMedium"
              class="setting-input"
              step="100"
            />
            <span class="setting-unit">RPM</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Hard (75% Cut)</span>
            <input
              type="number"
              id="setLimiterHard"
              class="setting-input"
              step="100"
            />
            <span class="setting-unit">RPM</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Full Cut (100%)</span>
            <input
              type="number"
              id="setLimiterFull"
              class="setting-input"
              step="100"
            />
            <span class="setting-unit">RPM</span>
          </div>
        </div>

        <!-- Shift Light -->
        <div class="settings-section">
          <h3>Shift Light</h3>
          <div class="setting-row">
            <span class="setting-label">LED On</span>
            <input
              type="number"
              id="setShiftOn"
              class="setting-input"
              step="100"
            />
            <span class="setting-unit">RPM</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Blink Start</span>
            <input
              type="number"
              id="setShiftBlink"
              class="setting-input"
              step="100"
            />
            <span class="setting-unit">RPM</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Fast Blink</span>
            <input
              type="number"
              id="setShiftFast"
              class="setting-input"
              step="100"
            />
            <span class="setting-unit">RPM</span>
          </div>
        </div>

        <!-- Cranking -->
        <div class="settings-section">
          <h3>Cranking</h3>
          <div class="setting-row">
            <span class="setting-label">Enable</span>
            <select id="setCrankingEnable" class="setting-select">
              <option value="ON">ON</option>
              <option value="OFF">OFF</option>
            </select>
            <span class="setting-unit"></span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Fixed Timing</span>
            <input type="number" id="setCrankingTiming" class="setting-input" />
            <span class="setting-unit">Â°</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Max RPM</span>
            <input
              type="number"
              id="setCrankingRpm"
              class="setting-input"
              step="50"
            />
            <span class="setting-unit">RPM</span>
          </div>
        </div>

        <!-- Safety -->
        <div class="settings-section">
          <h3>Safety & Warning</h3>
          <div class="setting-row">
            <span class="setting-label">Over-Rev Warning</span>
            <input
              type="number"
              id="setOverrevRpm"
              class="setting-input"
              step="100"
            />
            <span class="setting-unit">RPM</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Overheat Temp</span>
            <input
              type="number"
              id="setOverheatTemp"
              class="setting-input"
              step="1"
            />
            <span class="setting-unit">Â°C</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Low Battery</span>
            <input
              type="number"
              id="setLowBattery"
              class="setting-input"
              step="0.1"
            />
            <span class="setting-unit">V</span>
          </div>
        </div>

        <!-- Temperature Retard -->
        <div class="settings-section">
          <h3>Temp Retard</h3>
          <div class="setting-row">
            <span class="setting-label">Max Retard</span>
            <input type="number" id="setOverheatRetard" class="setting-input" />
            <span class="setting-unit">Â°</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Start Temp</span>
            <input
              type="number"
              id="setRetardStart"
              class="setting-input"
              min="50"
              max="120"
              step="5"
            />
            <span class="setting-unit">Â°C</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Per 10Â°C</span>
            <input
              type="number"
              id="setRetardPer10C"
              class="setting-input"
              min="5"
              max="30"
              step="1"
            />
            <span class="setting-unit">x0.1Â°</span>
          </div>
        </div>

        <!-- Quick Shifter (Strain Gauge Sensor) -->
        <div class="settings-section">
          <h3>Quick Shifter</h3>
          <div class="setting-row">
            <span class="setting-label">Enable</span>
            <select id="setQsEnable" class="setting-select">
              <option value="OFF">OFF</option>
              <option value="ON">ON</option>
            </select>
            <span class="setting-unit"></span>
          </div>
          <!-- Calibration Section -->
          <div
            style="
              background: rgba(255, 200, 0, 0.1);
              border-radius: 8px;
              padding: 10px;
              margin: 10px 0;
              border: 1px solid rgba(255, 200, 0, 0.3);
            "
          >
            <div
              style="
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 8px;
              "
            >
              <span style="color: #ffc800; font-weight: bold; font-size: 0.9em"
                >Sensor Calibration</span
              >
              <span
                id="qsLiveAdc"
                style="color: #00d4ff; font-size: 1.2em; font-weight: bold"
                >ADC: --</span
              >
            </div>
            <div style="display: flex; gap: 8px; margin-bottom: 8px">
              <button
                class="btn btn-secondary btn-sm"
                onclick="qsReadBaseline()"
                style="flex: 1"
              >
                ðŸ“ Read Baseline
              </button>
              <button
                class="btn btn-warning btn-sm"
                onclick="qsCaptureThreshold()"
                style="flex: 1"
              >
                âš¡ Capture Threshold
              </button>
            </div>
            <div
              style="
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                padding: 8px;
                position: relative;
                height: 24px;
                margin-bottom: 8px;
              "
            >
              <div
                id="qsAdcBar"
                style="
                  position: absolute;
                  left: 0;
                  top: 0;
                  height: 100%;
                  background: linear-gradient(90deg, #00d4ff, #ffc800);
                  border-radius: 6px;
                  width: 50%;
                  transition: width 0.1s;
                "
              ></div>
              <div
                id="qsThresholdLine"
                style="
                  position: absolute;
                  top: 0;
                  height: 100%;
                  width: 2px;
                  background: #ff4444;
                  border-radius: 1px;
                "
                title="Threshold"
              ></div>
              <div
                id="qsBaselineLine"
                style="
                  position: absolute;
                  top: 0;
                  height: 100%;
                  width: 2px;
                  background: #44ff44;
                  border-radius: 1px;
                "
                title="Baseline"
              ></div>
            </div>
            <div style="display: flex; gap: 10px">
              <div style="flex: 1">
                <span style="color: #44ff44; font-size: 0.75em">Baseline</span>
                <input
                  type="number"
                  id="setQsBaseline"
                  class="setting-input"
                  style="width: 100%"
                  min="0"
                  max="4095"
                />
              </div>
              <div style="flex: 1">
                <span style="color: #ff4444; font-size: 0.75em">Threshold</span>
                <input
                  type="number"
                  id="setQsThreshold"
                  class="setting-input"
                  style="width: 100%"
                  min="0"
                  max="4095"
                />
              </div>
            </div>
          </div>
          <div class="setting-row">
            <span class="setting-label">Min RPM</span>
            <input
              type="number"
              id="setQsMinRpm"
              class="setting-input"
              step="500"
              min="0"
              max="15000"
            />
            <span class="setting-unit">RPM</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Max RPM</span>
            <input
              type="number"
              id="setQsMaxRpm"
              class="setting-input"
              step="500"
              min="1000"
              max="20000"
            />
            <span class="setting-unit">RPM</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Debounce</span>
            <input
              type="number"
              id="setQsSensitivity"
              class="setting-input"
              min="1"
              max="50"
            />
            <span class="setting-unit">ms</span>
          </div>
        </div>

        <!-- ADC Calibration -->
        <div class="settings-section">
          <h3>ADC Calibration</h3>
          <div class="setting-row">
            <span class="setting-label">Temp Offset</span>
            <input type="number" id="setCalTempOffset" class="setting-input" />
            <span class="setting-unit">x10</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Temp Scale</span>
            <input type="number" id="setCalTempScale" class="setting-input" />
            <span class="setting-unit">def: 5001</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Batt Scale</span>
            <input type="number" id="setCalBattScale" class="setting-input" />
            <span class="setting-unit">def: 9090</span>
          </div>
          <div class="setting-row">
            <span class="setting-label">Charge Scale</span>
            <input
              type="number"
              id="setCalChargingScale"
              class="setting-input"
            />
            <span class="setting-unit">def: 9090</span>
          </div>
        </div>

        <!-- Auto Calibration -->
        <div class="settings-section">
          <h3>Auto Calibration</h3>
          <p style="color: #777; font-size: 0.8em; margin-bottom: 12px">
            RAW ADC realtime, masukkan nilai multimeter lalu Calc
          </p>
          <div class="setting-row">
            <span class="setting-label">RAW ADC</span>
            <span id="rawAdcValues" style="color: #00d4ff; font-size: 0.85em"
              >T:-- B:-- C:--</span
            >
          </div>
          <div class="setting-row">
            <span class="setting-label">Battery</span>
            <input
              type="number"
              id="actualBattVoltage"
              class="setting-input"
              step="0.1"
              placeholder="V"
              min="0"
              max="30"
            />
            <button
              class="btn btn-primary btn-sm"
              onclick="autoCalibrateVoltage('batt')"
            >
              Calc
            </button>
          </div>
          <div class="setting-row">
            <span class="setting-label">Charging</span>
            <input
              type="number"
              id="actualChargingVoltage"
              class="setting-input"
              step="0.1"
              placeholder="V"
              min="0"
              max="30"
            />
            <button
              class="btn btn-primary btn-sm"
              onclick="autoCalibrateVoltage('charging')"
            >
              Calc
            </button>
          </div>
          <div class="setting-row">
            <span class="setting-label">Temperature</span>
            <input
              type="number"
              id="actualTemp"
              class="setting-input"
              step="1"
              placeholder="Â°C"
              min="0"
              max="500"
            />
            <button
              class="btn btn-primary btn-sm"
              onclick="autoCalibrateTemp()"
            >
              Calc
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Files Tab (with integrated Console) -->
    <div id="files" class="tab-content">
      <div class="files-container">
        <!-- Left: File Browser -->
        <div class="files-main">
          <div class="files-header">
            <div class="files-toolbar">
              <button class="btn btn-secondary" onclick="refreshFiles()">
                â†» Refresh
              </button>
              <button class="btn btn-primary" onclick="navigateUp()">
                â†‘ Up
              </button>
              <span id="currentPath" class="current-path">/racing-cdi</span>
            </div>
            <div class="disk-info" id="diskInfo">
              <span class="disk-label">SD:</span>
              <span id="diskStatus">--</span>
            </div>
          </div>

          <div class="file-list" id="fileList">
            <div class="file-item file-loading">Loading...</div>
          </div>

          <div class="file-viewer" id="fileViewer">
            <div
              class="file-viewer-header"
              id="fileViewerHeader"
              style="display: none"
            >
              <span class="viewer-filename" id="viewerFileName"
                >filename.csv</span
              >
              <span id="viewerFileSize" class="file-size"></span>
              <button class="btn btn-success" onclick="downloadCurrentFile()">
                â†“ Download
              </button>
              <button class="btn btn-danger" onclick="deleteCurrentFile()">
                âœ• Delete
              </button>
              <button class="btn btn-secondary" onclick="closeViewer()">
                Close
              </button>
            </div>
            <pre
              class="file-content"
              id="fileContent"
            ><div class="file-viewer-empty"><span class="icon">ðŸ“„</span><span>Select a file to view</span></div></pre>
          </div>
        </div>

        <!-- Right: Console + Quick Actions -->
        <div class="files-sidebar">
          <!-- Quick Actions -->
          <div class="quick-actions">
            <div class="quick-actions-title">Quick Actions</div>
            <div class="quick-actions-grid">
              <button class="btn btn-warning" onclick="reinitSD()">
                Reinit SD
              </button>
              <button class="btn btn-danger" onclick="resetMCU()">
                Reset MCU
              </button>
              <button
                class="btn btn-success"
                onclick="document.getElementById('fileUpload').click()"
              >
                Upload File
              </button>
              <button class="btn btn-primary" onclick="exportConfig()">
                Export Config
              </button>
              <button class="btn btn-info" onclick="importConfig()">
                Import Config
              </button>
              <button class="btn btn-secondary" onclick="clearConsole()">
                Clear Log
              </button>
            </div>
            <input
              type="file"
              id="fileUpload"
              style="display: none"
              onchange="uploadFile(this)"
              accept=".txt,.csv,.bin,.map"
            />
          </div>

          <!-- Console Panel -->
          <div class="console-panel">
            <div class="console-header">
              <span class="console-title">SERIAL CONSOLE</span>
            </div>
            <div class="console" id="consoleOutput"></div>
            <div class="console-input">
              <input
                type="text"
                id="cmdInput"
                placeholder="Command (HELP, STATUS, GET...)"
                onkeypress="handleKey(event)"
              />
              <button class="btn btn-primary" onclick="sendManualCmd()">
                Send
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
      // ============================================================================
      // GLOBAL STATE
      // ============================================================================
      let ws = null;
      let reconnectTimer = null;
      let currentMapNum = 1;
      let lastDataTime = 0;
      let connectedPort = "";
      let heartbeatInterval = null;
      let reconnectStartTime = 0;
      let mapData = {}; // Store all 6 maps
      let mapDataOriginal = {}; // Original data from MCU (for diff)
      let clipboardMap = null;
      let liveRpm = 0;
      let liveTiming = 0;

      // Graph data arrays (store last 100 points)
      const GRAPH_POINTS = 100;
      let graphDataRpm = new Array(GRAPH_POINTS).fill(0);
      let graphDataTemp = new Array(GRAPH_POINTS).fill(0);
      let graphDataBatt = new Array(GRAPH_POINTS).fill(0);
      let graphDataCharging = new Array(GRAPH_POINTS).fill(0);
      let graphDataCpu = new Array(GRAPH_POINTS).fill(0);
      let graphDataRam = new Array(GRAPH_POINTS).fill(0);

      // Initialize empty maps
      for (let i = 1; i <= 6; i++) {
        mapData[i] = new Array(81).fill(10); // Default 10 deg
      }

      // Quick Shifter map: 21 points (0-20000 RPM in 1000 RPM steps)
      // Values are cut time in ms (10-250)
      let qsMapData = new Array(21).fill(50); // Default 50ms
      let qsMapOriginal = new Array(21).fill(50);

      // ============================================================================
      // WEBSOCKET CONNECTION
      // ============================================================================
      function connect() {
        const protocol = location.protocol === "https:" ? "wss:" : "ws:";
        ws = new WebSocket(`${protocol}//${location.host}/ws`);

        ws.onopen = () => {
          console.log("WebSocket connected to bridge");
        };

        ws.onclose = () => {
          console.log("WebSocket disconnected from bridge");
          document.getElementById("connStatus").textContent = "BRIDGE OFFLINE";
          document.getElementById("connStatus").className =
            "status-indicator status-disconnected";
          // Clear pending GET queue to prevent stale expectations on reconnect
          pendingGet = [];
          cmdQueue = [];
          cmdBusy = false;
          reconnectTimer = setTimeout(connect, 2000);
        };

        ws.onerror = (err) => {
          console.error("WebSocket error:", err);
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);

            // Only update lastDataTime for actual RT data (has rpm)
            if (data.rpm !== undefined) {
              lastDataTime = Date.now();
            }

            // Handle port list response
            if (data.type === "ports" || data.ports) {
              updatePortList(data.ports);
            }

            // Handle connect result
            if (data.type === "connect_result") {
              if (data.success) {
                connectedPort = data.port;
                if (!reconnectStartTime) {
                  showToast("Connected to " + data.port, "success");
                }
                startHeartbeat();
                // Load dashboard info after connection
                setTimeout(() => {
                  loadDashboardInfo();
                  refreshLogList();
                }, 500);
              } else {
                // Don't show error toast if we're auto-reconnecting
                if (!reconnectStartTime) {
                  showToast("Failed to connect to " + data.port, "error");
                }
              }
            }

            // Handle disconnect result
            if (data.type === "disconnect_result") {
              connectedPort = "";
              stopHeartbeat();
              showToast("Disconnected", "info");
            }

            // Handle realtime data or response
            if (data.type === "response") {
              handleResponse(data.data);
            } else if (data.rpm !== undefined || data.connected !== undefined) {
              updateUI(data);
            }
          } catch (e) {
            // Plain text response
            handleResponse(event.data);
          }
        };
      }

      // Heartbeat checker - auto reconnect if no data for 1 second
      function startHeartbeat() {
        stopHeartbeat();
        lastDataTime = Date.now();
        reconnectStartTime = 0;
        heartbeatInterval = setInterval(checkHeartbeat, 500);
      }

      function stopHeartbeat() {
        if (heartbeatInterval) {
          clearInterval(heartbeatInterval);
          heartbeatInterval = null;
        }
        reconnectStartTime = 0;
      }

      function checkHeartbeat() {
        if (!connectedPort) return;

        const now = Date.now();
        const elapsed = now - lastDataTime;

        // No data for 1 second - try reconnect
        if (elapsed > 1000) {
          // Start tracking reconnect time (only once)
          if (!reconnectStartTime) {
            reconnectStartTime = now;
          }

          // Update status header
          document.getElementById("connStatus").textContent = "RECONNECTING...";
          document.getElementById("connStatus").className =
            "status-indicator status-disconnected";

          // Check if 5 minutes passed - give up
          if (now - reconnectStartTime > 300000) {
            showToast("Connection failed", "error");
            disconnectPort();
            return;
          }

          // Try reconnect
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: "connect", port: connectedPort }));
          }
        } else {
          // Data received - reset
          if (reconnectStartTime) {
            reconnectStartTime = 0;
          }
        }
      }

      // ============================================================================
      // PORT MANAGEMENT
      // ============================================================================
      function updatePortList(ports) {
        const select = document.getElementById("portSelect");
        const currentValue = select.value;

        // Clear and rebuild options
        select.innerHTML = '<option value="">-- Select Port --</option>';

        if (ports && ports.length > 0) {
          ports.forEach((port) => {
            const option = document.createElement("option");
            option.value = port.device;
            option.textContent = `${port.device} (${port.description})`;
            select.appendChild(option);
          });

          // Restore selection if still available
          if (currentValue) {
            select.value = currentValue;
          }
        }
      }

      function refreshPorts() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ action: "list_ports" }));
          showToast("Refreshing ports...", "info");
        }
      }

      function connectPort() {
        const select = document.getElementById("portSelect");
        const port = select.value;

        if (!port) {
          showToast("Select a port first", "error");
          return;
        }

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ action: "connect", port: port }));
          showToast("Connecting to " + port + "...", "info");
        }
      }

      function disconnectPort() {
        stopHeartbeat();
        connectedPort = "";
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ action: "disconnect" }));
        }
      }

      // ============================================================================
      // UI UPDATE
      // ============================================================================
      function updateUI(data) {
        // Connection status
        const connStatus = document.getElementById("connStatus");
        const btnConnect = document.getElementById("btnConnect");
        const btnDisconnect = document.getElementById("btnDisconnect");
        const portSelect = document.getElementById("portSelect");

        if (data.connected) {
          if (!reconnectStartTime) {
            connStatus.textContent = data.portName || "CONNECTED";
            connStatus.className = "status-indicator status-connected";
          }
          btnConnect.style.display = "none";
          btnDisconnect.style.display = "";
          portSelect.disabled = true;

          // Track connected port and start heartbeat
          if (data.portName && !connectedPort) {
            connectedPort = data.portName;
            startHeartbeat();
            // Check defaults status on connect
            setTimeout(checkDefaultsStatus, 500);
          }

          // Update port select to show connected port
          if (data.portName && portSelect.value !== data.portName) {
            portSelect.value = data.portName;
          }
        } else {
          connStatus.textContent = "DISCONNECTED";
          connStatus.className = "status-indicator status-disconnected";
          btnConnect.style.display = "";
          btnDisconnect.style.display = "none";
          portSelect.disabled = false;

          // Clear connection tracking
          if (connectedPort && !reconnectStartTime) {
            connectedPort = "";
            stopHeartbeat();
          }
        }

        // RPM
        const rpm = data.rpm || 0;
        document.getElementById("rpmValue").textContent = rpm;
        const rpmPercent = Math.min(100, (rpm / 15000) * 100);
        document.getElementById("rpmBar").style.width = rpmPercent + "%";

        // Live RPM in header
        const liveRpmEl = document.getElementById("liveRpm");
        liveRpmEl.textContent = rpm;
        liveRpmEl.className =
          "live-value" +
          (rpm > 10000 ? " danger" : rpm > 8000 ? " warning" : "");

        // Timing
        const timing = data.timing || 0;
        document.getElementById("timingValue").textContent = timing;

        // Live Timing in header
        document.getElementById("liveTiming").textContent = timing + "Â°";

        // Temp (already in Celsius from firmware)
        document.getElementById("tempValue").textContent = data.temp || 0;

        // Battery (x10 from firmware, e.g., 126 = 12.6V)
        const batt = data.battery ? (data.battery / 10).toFixed(1) : "0.0";
        document.getElementById("battValue").textContent = batt;

        // Charging (x10 from firmware)
        const charging = data.charging
          ? (data.charging / 10).toFixed(1)
          : "0.0";
        document.getElementById("chargingValue").textContent = charging;

        // dRPM - RPM change per cycle (precision timing)
        const dRpm = data.dRpm || 0;
        const dRpmEl = document.getElementById("dRpmValue");
        if (dRpmEl) {
          dRpmEl.textContent = (dRpm > 0 ? "+" : "") + dRpm;
          // Color: green for accel, red for decel, white for stable
          dRpmEl.style.color = dRpm > 50 ? "#00ff88" : dRpm < -50 ? "#ff4444" : "#fff";
        }

        // Phase Correction - timing phase lock (precision timing)
        const phaseCorr = data.phaseCorr || 0;
        const phaseCorrEl = document.getElementById("phaseCorrValue");
        if (phaseCorrEl) {
          phaseCorrEl.textContent = (phaseCorr > 0 ? "+" : "") + phaseCorr;
          // Color: cyan when correcting, white when stable
          phaseCorrEl.style.color = Math.abs(phaseCorr) > 10 ? "#00d4ff" : "#fff";
        }

        // Map
        document.getElementById("mapStatus").textContent =
          "MAP " + (data.map || 1);
        document.querySelectorAll(".map-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.map == data.map);
        });

        // Update map editor tabs to show active map indicator
        document.querySelectorAll(".map-tab").forEach((btn) => {
          const isActive = btn.dataset.mapnum == data.map;
          btn.style.background = isActive ? "rgba(0, 200, 83, 0.3)" : "";
          btn.style.borderColor = isActive ? "#00c853" : "";
        });

        // Engine status
        const engineEl = document.getElementById("engineStatus");
        if (data.engineRunning) {
          engineEl.textContent = "ENGINE RUNNING";
          engineEl.className = "status-indicator status-ok";
        } else {
          engineEl.textContent = "ENGINE OFF";
          engineEl.className = "status-indicator status-warning";
        }

        // Limiter stages
        for (let i = 1; i <= 4; i++) {
          document
            .getElementById("lim" + i)
            .classList.toggle("active", (data.limiter || 0) >= i);
        }

        // Flags
        document
          .getElementById("flagEngine")
          .classList.toggle("active", data.engineRunning);
        document
          .getElementById("flagEngine")
          .classList.toggle("ok", data.engineRunning);
        document
          .getElementById("flagOverheat")
          .classList.toggle("active", data.overheating);
        document
          .getElementById("flagLowBatt")
          .classList.toggle("active", data.lowBattery);
        document
          .getElementById("flagKill")
          .classList.toggle("active", data.killActive);
        document
          .getElementById("flagSdOk")
          .classList.toggle("active", data.sdCardOk);
        document
          .getElementById("flagSdOk")
          .classList.toggle("ok", data.sdCardOk);

        // Config source indicator: 0=SD, 1=Flash, 2=Hardcoded
        const cfgEl = document.getElementById("flagConfigSource");
        cfgEl.classList.remove("cfg-sd", "cfg-flash", "cfg-hardcoded");
        const cfgSrc = data.configSource || 0;
        let cfgText = "",
          cfgColor = "";
        if (cfgSrc === 0) {
          cfgEl.textContent = "CFG: SD";
          cfgEl.classList.add("cfg-sd");
          cfgText = "Config loaded from: SD Card";
          cfgColor = "#00ff88";
        } else if (cfgSrc === 1) {
          cfgEl.textContent = "CFG: FLASH";
          cfgEl.classList.add("cfg-flash");
          cfgText = "Config loaded from: FLASH (SD failed)";
          cfgColor = "#ffaa00";
        } else {
          cfgEl.textContent = "CFG: DEFAULT";
          cfgEl.classList.add("cfg-hardcoded");
          cfgText = "Config loaded from: HARDCODED (SD & Flash failed)";
          cfgColor = "#ff6666";
        }
        // Update Settings tab indicator
        const cfgSettings = document.getElementById("configSourceSettings");
        if (cfgSettings) {
          cfgSettings.innerHTML = cfgText;
          cfgSettings.style.color = cfgColor;
        }
        // Update Map tab indicator
        const cfgMap = document.getElementById("configSourceMap");
        if (cfgMap) {
          cfgMap.innerHTML = cfgText;
          cfgMap.style.color = cfgColor;
        }

        // Track state for dashboard display only
        window.lastSdCardOk = data.sdCardOk;

        // Update ignition button status
        if (data.ignitionEnabled !== undefined) {
          updateIgnitionButton(data.ignitionEnabled);
        }

        // Peak RPM
        document.getElementById("peakValue").textContent = data.peak || 0;

        // Store live RPM/timing for map graph
        liveRpm = data.rpm || 0;
        liveTiming = data.timing || 0;

        // Redraw map canvas if on maps tab (for live RPM indicator)
        if (document.getElementById("maps").classList.contains("active")) {
          drawMapCanvas();
        }

        // Update realtime graphs
        const gRpm = data.rpm || 0;
        const gTemp = data.temp || 0;
        const gBatt = data.battery ? data.battery / 10 : 0;
        const gCharging = data.charging ? data.charging / 10 : 0;

        // Push new data and shift old
        graphDataRpm.push(gRpm);
        graphDataRpm.shift();
        graphDataTemp.push(gTemp);
        graphDataTemp.shift();
        graphDataBatt.push(gBatt);
        graphDataBatt.shift();
        graphDataCharging.push(gCharging);
        graphDataCharging.shift();

        // CPU and RAM usage
        const gCpu = data.cpu || 0;
        const gRam = data.ram || 0;
        graphDataCpu.push(gCpu);
        graphDataCpu.shift();
        graphDataRam.push(gRam);
        graphDataRam.shift();

        // Update graph values display
        document.getElementById("graphRpmValue").textContent = gRpm;
        document.getElementById("graphTempValue").textContent = gTemp + "Â°C";
        document.getElementById("graphBattValue").textContent =
          gBatt.toFixed(1) + "V";
        document.getElementById("graphChargingValue").textContent =
          gCharging.toFixed(1) + "V";
        document.getElementById("graphCpuValue").textContent = gCpu + "%";
        document.getElementById("graphRamValue").textContent = gRam + "%";

        // Draw all graphs only if dashboard tab is active
        if (document.getElementById("dashboard").classList.contains("active")) {
          drawGraph("graphRpm", graphDataRpm, 0, 15000, "#00ff88", "");
          drawGraph("graphTemp", graphDataTemp, 0, 200, "#ff9100", "Â°C");
          drawGraph("graphBatt", graphDataBatt, 8, 16, "#00d4ff", "V");
          drawGraph("graphCharging", graphDataCharging, 8, 16, "#ffff00", "V");
          drawGraph("graphCpu", graphDataCpu, 0, 100, "#ff00ff", "%");
          drawGraph("graphRam", graphDataRam, 0, 100, "#00ffff", "%");
        }

        // Update scope data from RT stream
        if (data.trigAngle !== undefined) {
          scopeData.rpm = data.rpm || 0;
          scopeData.timing = data.timing || 0;
          scopeData.triggerAngle = data.trigAngle || 0;
          scopeData.cut = data.cut || 0;
          scopeData.limiter = data.limiter || 0;
          scopeData.engineType = data.engType || 2;

          // Draw scope if tab is active
          if (document.getElementById("maps").classList.contains("active")) {
            drawScope();
          }
        }

        // Update Quick Shifter ADC from RT stream (no need for separate polling)
        if (data.qsAdc !== undefined) {
          updateQsCalibrationDisplay(data.qsAdc);
        }

        // Update Raw ADC values for calibration (no need for Read button)
        if (data.tempRaw !== undefined) {
          updateRawAdcDisplay(data.tempRaw, data.battRaw, data.chrgRaw);
        }
      }

      // ============================================================================
      // GRAPH DRAWING
      // ============================================================================
      function drawGraph(
        canvasId,
        data,
        minVal,
        maxVal,
        color,
        unit = "",
        autoScale = true
      ) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext("2d");
        const rect = canvas.getBoundingClientRect();

        // Skip if canvas not visible or has no size
        if (rect.width < 10 || rect.height < 10) return;

        // Set canvas size to match CSS size
        canvas.width = rect.width;
        canvas.height = rect.height;

        const w = canvas.width;
        const h = canvas.height;
        const padding = 5;

        // Auto scale: find min/max from data with padding
        if (autoScale) {
          const dataMin = Math.min(...data);
          const dataMax = Math.max(...data);
          const range = dataMax - dataMin;
          const pad = range * 0.1 || 1; // 10% padding or 1 if flat
          minVal = Math.max(0, Math.floor(dataMin - pad));
          maxVal = Math.ceil(dataMax + pad);
          // Ensure minimum range
          if (maxVal - minVal < 1) {
            maxVal = minVal + 1;
          }
        }

        // Update range labels
        const container = canvas.parentElement;
        if (container) {
          const rangeEl = container.querySelector(".graph-range");
          if (rangeEl) {
            const spans = rangeEl.querySelectorAll("span");
            if (spans.length >= 2) {
              spans[0].textContent = minVal + unit;
              spans[1].textContent = maxVal + unit;
            }
          }
        }

        // Clear canvas
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(0, 0, w, h);

        // Draw grid lines
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        for (let i = 1; i < 4; i++) {
          const y = (h / 4) * i;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.stroke();
        }

        // Draw data line
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();

        const range = maxVal - minVal;
        for (let i = 0; i < data.length; i++) {
          const x = (i / (data.length - 1)) * w;
          const normalized = (data[i] - minVal) / range;
          const y = h - padding - normalized * (h - padding * 2);

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // Draw fill gradient
        ctx.beginPath();
        for (let i = 0; i < data.length; i++) {
          const x = (i / (data.length - 1)) * w;
          const normalized = (data[i] - minVal) / range;
          const y = h - padding - normalized * (h - padding * 2);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();

        // Convert hex to rgba for gradient
        let r = 0,
          g = 0,
          b = 0;
        if (color.startsWith("#")) {
          const hex = color.slice(1);
          r = parseInt(hex.substr(0, 2), 16);
          g = parseInt(hex.substr(2, 2), 16);
          b = parseInt(hex.substr(4, 2), 16);
        }
        const gradient = ctx.createLinearGradient(0, 0, 0, h);
        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
        gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = gradient;
        ctx.fill();
      }

      // Track which GET command we're expecting response for
      let pendingGet = [];
      let pendingGetTimeout = null;

      // Clear stale pendingGet queue after timeout (prevents permanent stuck)
      function resetPendingGetTimeout() {
        if (pendingGetTimeout) clearTimeout(pendingGetTimeout);
        pendingGetTimeout = setTimeout(() => {
          if (pendingGet.length > 0) {
            console.warn("Clearing stale pendingGet queue:", pendingGet);
            pendingGet = [];
          }
        }, 3000); // 3 second timeout
      }

      function handleResponse(text) {
        logConsole(text, "resp");

        // Check for download in progress (highest priority for CAT responses)
        if (processDownload(text)) {
          return;
        }

        // Check for log viewer responses first (has priority over file manager)
        if (handleLogResponse(text)) {
          return;
        }

        // Check for file manager responses
        if (handleFileResponse(text)) {
          return;
        }

        // Check for save notifications from MCU
        if (text.startsWith("Config saved")) {
          showToast(text, "success");
          return;
        }
        if (text.startsWith("Save failed")) {
          showToast(text, "error");
          return;
        }
        if (text === "SAVE:BUSY") {
          showToast(
            "Cannot save while engine running! Stop engine first.",
            "warning"
          );
          return;
        }
        if (text.startsWith("Auto-saving")) {
          showToast(text, "info");
          return;
        }

        // Flash defaults responses
        if (handleDefaultsResponse(text)) {
          return;
        }
        if (text.startsWith("SAVEDEFAULT:")) {
          if (text.startsWith("SAVEDEFAULT:OK,")) {
            // Format: SAVEDEFAULT:OK,mapNum,writeCount
            const parts = text.substring(15).split(",");
            const mapNum = parts[0];
            const writes = parts[1];
            showToast(
              `Map ${mapNum} saved to Flash! (${writes} writes)`,
              "success"
            );
            checkDefaultsStatus();
          } else {
            showToast(text.substring(12), "error");
          }
          return;
        }
        if (text.startsWith("CLEARDEFAULT:")) {
          showToast(
            text.includes("OK")
              ? "Custom defaults cleared"
              : text.substring(13),
            text.includes("OK") ? "success" : "error"
          );
          return;
        }
        if (text.startsWith("LOADDEFAULT:")) {
          if (text.includes("FLASH")) {
            showToast("Safety map loaded from Flash to all maps", "success");
          } else if (text.includes("HARDCODED")) {
            showToast("Factory defaults loaded to all maps", "info");
          } else {
            showToast(text.substring(12), "error");
          }
          checkDefaultsStatus();
          return;
        }
        // New separate Settings/Map Flash commands
        if (text.startsWith("SAVESETTINGS:")) {
          if (text.startsWith("SAVESETTINGS:OK,")) {
            const writes = text.substring(16);
            showToast(`Settings saved to Flash! (${writes} writes)`, "success");
            checkDefaultsStatus();
          } else {
            showToast(text.substring(13), "error");
          }
          return;
        }
        if (text.startsWith("LOADSETTINGS:")) {
          if (text === "LOADSETTINGS:OK") {
            showToast("Settings loaded from Flash", "success");
          } else if (text === "LOADSETTINGS:NO_DATA") {
            showToast("No settings in Flash", "warning");
          } else {
            showToast(text.substring(13), "error");
          }
          return;
        }
        // READ ONLY: Display Flash settings in UI (does NOT overwrite MCU config)
        if (text.startsWith("FLASHSETTINGS:")) {
          if (text === "FLASHSETTINGS:NO_DATA") {
            showToast("No settings in Flash", "warning");
          } else {
            // Parse: trigAngle,edge,noiseFilter,pulse,soft,med,hard,full,shiftOn,shiftBlink,shiftFast,
            //        crankEn,crankTiming,crankMax,warnOverrev,warnOverheat,warnLowBatt,warnRetard,retardStart,retardPer10,engType,
            //        calTempOffset,calTempScale,calBattScale,calChargingScale
            const parts = text.substring(14).split(",");
            if (parts.length >= 25) {
              document.getElementById("setTriggerAngle").value = (
                parseInt(parts[0]) / 100
              ).toFixed(2);
              document.getElementById("setTriggerEdge").value =
                parts[1] === "1" ? "RISING" : "FALLING";
              document.getElementById("setNoiseFilter").value =
                parseInt(parts[2]) / 10; // ticks to us
              document.getElementById("setCdiPulse").value = parts[3];
              document.getElementById("setLimiterSoft").value = parts[4];
              document.getElementById("setLimiterMedium").value = parts[5];
              document.getElementById("setLimiterHard").value = parts[6];
              document.getElementById("setLimiterFull").value = parts[7];
              document.getElementById("setShiftOn").value = parts[8];
              document.getElementById("setShiftBlink").value = parts[9];
              document.getElementById("setShiftFast").value = parts[10];
              document.getElementById("setCrankingEnable").value =
                parts[11] === "1" ? "ON" : "OFF";
              document.getElementById("setCrankingTiming").value = parts[12];
              document.getElementById("setCrankingRpm").value = parts[13];
              document.getElementById("setOverrevRpm").value = parts[14];
              document.getElementById("setOverheatTemp").value = parts[15];
              document.getElementById("setLowBattery").value = (
                parseInt(parts[16]) / 1000
              ).toFixed(1); // mV to V
              document.getElementById("setOverheatRetard").value = parts[17];
              document.getElementById("setRetardStart").value = parts[18];
              document.getElementById("setRetardPer10C").value = parts[19];
              document.getElementById("setEngineType").value = parts[20];
              // ADC Calibration (4 fields)
              document.getElementById("setCalTempOffset").value = parts[21];
              document.getElementById("setCalTempScale").value = parts[22];
              document.getElementById("setCalBattScale").value = parts[23];
              document.getElementById("setCalChargingScale").value = parts[24];
              // Update data source indicator
              const srcEl = document.getElementById("settingsDataSource");
              if (srcEl) {
                srcEl.innerHTML =
                  'ðŸ’¾ Data displayed from: <b style="color:#ffaa00">FLASH</b> (view only, click Apply to send to MCU)';
              }
              showToast("Settings loaded from FLASH (view only)", "success");
            }
          }
          return;
        }
        // QS Flash commands
        if (text.startsWith("SAVEQS:")) {
          if (text.startsWith("SAVEQS:OK,")) {
            const writes = text.substring(10);
            showToast(
              `QS config saved to Flash! (${writes} writes)`,
              "success"
            );
            checkDefaultsStatus();
          } else {
            showToast(text.substring(7), "error");
          }
          return;
        }
        if (text.startsWith("LOADQS:")) {
          if (text === "LOADQS:OK") {
            showToast("QS config loaded from Flash", "success");
          } else if (text === "LOADQS:NO_DATA") {
            showToast("No QS config in Flash", "warning");
          } else {
            showToast(text.substring(7), "error");
          }
          return;
        }
        // READ ONLY: Display Flash QS config in UI (does NOT overwrite MCU config)
        if (text.startsWith("FLASHQS:")) {
          if (text === "FLASHQS:NO_DATA") {
            showToast("No QS config in Flash", "warning");
          } else {
            // Parse: enabled,sensitivity,baseline,threshold,minRpm,maxRpm
            const parts = text.substring(8).split(",");
            if (parts.length >= 6) {
              document.getElementById("setQsEnable").value =
                parts[0] === "1" ? "ON" : "OFF";
              document.getElementById("setQsSensitivity").value = parts[1];
              document.getElementById("setQsBaseline").value = parts[2];
              document.getElementById("setQsThreshold").value = parts[3];
              document.getElementById("setQsMinRpm").value = parts[4];
              document.getElementById("setQsMaxRpm").value = parts[5];
              updateQsCalibrationDisplay(qsCurrentAdc);
              showToast("QS config loaded from FLASH (view only)", "success");
            }
          }
          return;
        }
        // READ ONLY: Display Flash QS map in UI (does NOT overwrite MCU config)
        if (text.startsWith("FLASHQSMAP:")) {
          if (text === "FLASHQSMAP:NO_DATA") {
            showToast("No QS map in Flash", "warning");
          } else {
            // Parse: 21 values
            const parts = text.substring(11).split(",");
            if (parts.length >= 21) {
              for (let i = 0; i < 21; i++) {
                qsMapData[i] = parseInt(parts[i]) || 50;
              }
              initQsMapGrid();
              // Update data source indicator
              const srcEl = document.getElementById("qsDataSource");
              if (srcEl) {
                srcEl.innerHTML =
                  'ðŸ’¾ Data displayed from: <b style="color:#ffaa00">FLASH</b> (view only, click Upload to send to MCU)';
              }
              showToast("QS map loaded from FLASH (view only)", "success");
            }
          }
          return;
        }
        if (text.startsWith("SAVEMAP:")) {
          if (text.startsWith("SAVEMAP:OK,")) {
            const parts = text.substring(11).split(",");
            const mapNum = parts[0];
            const writes = parts[1];
            showToast(
              `Map ${mapNum} saved to Flash! (${writes} writes)`,
              "success"
            );
            checkDefaultsStatus();
          } else {
            showToast(text.substring(8), "error");
          }
          return;
        }
        if (text.startsWith("LOADMAP:")) {
          if (text.startsWith("LOADMAP:OK")) {
            const sourceMap = text.split(",")[1] || "";
            const mapInfo = sourceMap ? ` (from Map ${sourceMap})` : "";
            showToast(`Safety map loaded to all maps${mapInfo}`, "success");
          } else if (text === "LOADMAP:NO_DATA") {
            showToast("No safety map in Flash", "warning");
          } else {
            showToast(text.substring(8), "error");
          }
          return;
        }
        // READ ONLY: Display Flash ignition map in UI (does NOT overwrite MCU config)
        if (text.startsWith("FLASHMAP:")) {
          if (text === "FLASHMAP:NO_DATA") {
            showToast("No safety map in Flash", "warning");
          } else {
            // Parse: sourceMapNum:value0,value1,...,value80
            const colonIdx = text.indexOf(":", 9); // Find second colon after "FLASHMAP:"
            if (colonIdx > 0) {
              const sourceMap = text.substring(9, colonIdx);
              const parts = text.substring(colonIdx + 1).split(",");
              if (parts.length >= 81) {
                for (let i = 0; i < 81; i++) {
                  mapData[currentMapNum][i] = parseInt(parts[i]) || 0;
                }
                initMapTable();
                drawMapCanvas();
                // Update data source indicator
                const srcEl = document.getElementById("mapDataSource");
                if (srcEl) {
                  srcEl.innerHTML = `ðŸ’¾ Data displayed from: <b style="color:#ffaa00">FLASH (Map ${sourceMap})</b> (view only, click Upload to send to MCU)`;
                }
                showToast(
                  `Map loaded from FLASH (source: Map ${sourceMap}) - view only`,
                  "success"
                );
              }
            }
          }
          return;
        }

        // SD Card status messages
        if (text.startsWith("WARNING: SD card removed")) {
          showToast("SD Card removed! Logging stopped.", "error");
          return;
        }
        if (text.startsWith("SD reconnected") || text.includes("SD detected")) {
          showToast("SD Card detected - use Reset MCU to reinit", "warning");
          return;
        }
        // SDINIT responses handled by handleFileResponse

        // Filter out SET command responses (OK, Invalid, etc.) - don't let them interfere with GET queue
        if (
          text === "OK" ||
          text.startsWith("Invalid") ||
          text.startsWith("Error")
        ) {
          return; // Ignore SET responses, don't process as GET response
        }

        // Parse GET responses based on what we're expecting
        // Format: "MAP1:10,12,14,..." for MAP GET
        const mapMatch = text.match(/^MAP(\d):(.+)$/);
        if (mapMatch) {
          const mapNum = parseInt(mapMatch[1]);
          const values = mapMatch[2].split(",").map((v) => parseInt(v.trim()));
          if (values.length === 81) {
            mapData[mapNum] = [...values];
            mapDataOriginal[mapNum] = [...values]; // Store original for diff
            if (mapNum === currentMapNum) {
              initMapTable();
              drawMapCanvas();
            }
            // Update data source indicator
            const srcEl = document.getElementById("mapDataSource");
            if (srcEl) {
              srcEl.innerHTML =
                'ðŸ“‚ Data displayed from: <b style="color:#00ff88">MCU (RAM)</b>';
            }
            showToast("Map " + mapNum + " loaded from MCU (RAM)", "success");
          }
          // Remove MAP from pending if present
          const mapIdx = pendingGet.indexOf("MAP " + mapNum);
          if (mapIdx >= 0) pendingGet.splice(mapIdx, 1);
          return;
        }

        // Quick Shifter live ADC (unqueued response)
        if (text.startsWith("QSADC:")) {
          const adc = parseInt(text.substring(6)) || 0;
          updateQsCalibrationDisplay(adc);
          return;
        }

        // Get the pending command to know what type of response this is
        // Only shift if we have pending commands
        if (pendingGet.length === 0) return;
        const expecting = pendingGet[0]; // Peek first, don't shift yet

        // Parse based on expecting command
        if (expecting === "ENGINE") {
          const engineType = text.trim();
          // Validate it's actually engine type (2 or 4)
          if (engineType !== "2" && engineType !== "4") return;
          pendingGet.shift(); // Now remove from queue
          document.getElementById("setEngineType").value = engineType;
          // Update dashboard
          document.getElementById("dashEngine").textContent =
            engineType + "-Stroke";
          return;
        }

        if (expecting === "TRIGGER") {
          // Format: "angle,edge" (e.g., "30.00,RISING")
          const parts = text.split(",");
          if (parts.length < 2) return; // Not valid trigger response
          const edge = parts[1].trim();
          if (edge !== "RISING" && edge !== "FALLING") return; // Validate
          pendingGet.shift(); // Now remove from queue
          const angle = parseFloat(parts[0]) || 30;
          document.getElementById("setTriggerAngle").value = angle;
          document.getElementById("setTriggerEdge").value = edge;
          // Update dashboard
          document.getElementById("dashTrigger").textContent =
            angle + "Â° " + edge.charAt(0);
          return;
        }

        if (expecting === "NOISE") {
          const val = parseInt(text.trim());
          if (isNaN(val)) return; // Validate
          pendingGet.shift();
          document.getElementById("setNoiseFilter").value = val || 4;
          return;
        }

        if (expecting === "PULSE") {
          const val = parseInt(text.trim());
          if (isNaN(val)) return; // Validate
          pendingGet.shift();
          document.getElementById("setCdiPulse").value = val || 100;
          return;
        }

        if (expecting === "LIMITER") {
          const parts = text.split(",");
          if (parts.length < 4) return; // Validate
          pendingGet.shift();
          document.getElementById("setLimiterSoft").value =
            parseInt(parts[0]) || 11000;
          document.getElementById("setLimiterMedium").value =
            parseInt(parts[1]) || 11500;
          document.getElementById("setLimiterHard").value =
            parseInt(parts[2]) || 12000;
          document.getElementById("setLimiterFull").value =
            parseInt(parts[3]) || 12500;
          return;
        }

        if (expecting === "SHIFT") {
          const parts = text.split(",");
          if (parts.length < 3) return; // Validate
          pendingGet.shift();
          document.getElementById("setShiftOn").value = parseInt(parts[0]) || 0;
          document.getElementById("setShiftBlink").value =
            parseInt(parts[1]) || 0;
          document.getElementById("setShiftFast").value =
            parseInt(parts[2]) || 0;
          return;
        }

        if (expecting === "CRANKING") {
          const parts = text.split(",");
          if (parts.length < 3) return; // Validate
          const enable = parts[0].trim();
          if (enable !== "ON" && enable !== "OFF") return; // Validate
          pendingGet.shift();
          document.getElementById("setCrankingEnable").value = enable;
          document.getElementById("setCrankingTiming").value =
            parseInt(parts[1]) || 5;
          document.getElementById("setCrankingRpm").value =
            parseInt(parts[2]) || 500;
          return;
        }

        if (expecting === "WARNING") {
          // Format: overRevRpm,overheatTempC,lowBatteryV,overheatRetard
          const parts = text.split(",");
          if (parts.length < 4) return; // Validate
          pendingGet.shift();
          document.getElementById("setOverrevRpm").value =
            parseInt(parts[0]) || 12000;
          document.getElementById("setOverheatTemp").value =
            parseInt(parts[1]) || 120;
          document.getElementById("setLowBattery").value =
            parseFloat(parts[2]) || 11.0;
          document.getElementById("setOverheatRetard").value =
            parseInt(parts[3]) || 5;
          return;
        }

        if (expecting === "TEMP_RETARD") {
          // Format: retardStartTempC,retardPer10C
          const parts = text.split(",");
          if (parts.length < 2) return; // Validate
          pendingGet.shift();
          document.getElementById("setRetardStart").value =
            parseInt(parts[0]) || 80;
          document.getElementById("setRetardPer10C").value =
            parseInt(parts[1]) || 10;
          return;
        }

        if (expecting === "CAL") {
          const parts = text.split(",");
          if (parts.length < 4) return; // Validate
          pendingGet.shift();
          document.getElementById("setCalTempOffset").value =
            parseInt(parts[0]) || 0;
          document.getElementById("setCalTempScale").value =
            parseInt(parts[1]) || 5001;
          document.getElementById("setCalBattScale").value =
            parseInt(parts[2]) || 9090;
          document.getElementById("setCalChargingScale").value =
            parseInt(parts[3]) || 9090;
          return;
        }

        if (expecting === "QS") {
          // Format: QS:enabled,baseline,threshold,minRpm,maxRpm,sensitivity,currentAdc
          if (!text.startsWith("QS:")) return;
          const parts = text.substring(3).split(",");
          if (parts.length < 7) return; // Validate
          pendingGet.shift();
          document.getElementById("setQsEnable").value =
            parts[0] === "1" ? "ON" : "OFF";
          document.getElementById("setQsBaseline").value =
            parseInt(parts[1]) || 2048;
          document.getElementById("setQsThreshold").value =
            parseInt(parts[2]) || 2500;
          document.getElementById("setQsMinRpm").value =
            parseInt(parts[3]) || 3000;
          document.getElementById("setQsMaxRpm").value =
            parseInt(parts[4]) || 15000;
          document.getElementById("setQsSensitivity").value =
            parseInt(parts[5]) || 10;
          updateQsCalibrationDisplay(parseInt(parts[6]) || 0);
          return;
        }

        if (expecting === "QSMAP") {
          // Format: QSMAP:v0,v1,v2,...,v20 (21 values)
          if (!text.startsWith("QSMAP:")) return;
          resolvePending("QSMAP");
          const parts = text.substring(6).split(",");
          if (parts.length < 21) return; // Validate
          pendingGet.shift();
          for (let i = 0; i < 21; i++) {
            qsMapData[i] = parseInt(parts[i]) || 50;
            qsMapOriginal[i] = qsMapData[i];
          }
          initQsMapGrid();
          // Update data source indicator
          const srcEl = document.getElementById("qsDataSource");
          if (srcEl) {
            srcEl.innerHTML =
              'ðŸ“‚ Data displayed from: <b style="color:#00ff88">MCU (RAM)</b>';
          }
          showToast("QS Map loaded from MCU (RAM)", "success");
          return;
        }

        if (expecting === "RAW") {
          // For auto-calibration: parse raw ADC values
          const parts = text.split(",");
          if (parts.length < 3) return; // Validate
          pendingGet.shift();
          lastRawTemp = parseInt(parts[0]);
          lastRawBatt = parseInt(parts[1]);
          lastRawCharging = parseInt(parts[2]);
          return;
        }

        // If we get here, response didn't match expected - might be other message
        // Don't shift queue, let next response try
      }

      // ============================================================================
      // COMMANDS
      // ============================================================================
      let cmdQueue = [];
      let cmdBusy = false;

      function sendCmd(cmd) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ command: cmd }));
          logConsole("> " + cmd, "cmd");

          // Track GET commands for response parsing
          if (cmd.startsWith("GET ")) {
            pendingGet.push(cmd.substring(4));
            resetPendingGetTimeout(); // Auto-clear queue if stuck
          }
        } else {
          showToast("Not connected", "error");
        }
      }

      // Send command with rate limiting (50ms between commands)
      function sendCmdQueued(cmd) {
        cmdQueue.push(cmd);
        processQueue();
      }

      function processQueue() {
        if (cmdBusy || cmdQueue.length === 0) return;
        cmdBusy = true;
        const cmd = cmdQueue.shift();
        sendCmd(cmd);
        setTimeout(() => {
          cmdBusy = false;
          processQueue();
        }, 60); // 60ms delay for stability
      }

      function sendManualCmd() {
        const input = document.getElementById("cmdInput");
        if (input.value.trim()) {
          sendCmd(input.value.trim().toUpperCase());
          input.value = "";
        }
      }

      function handleKey(event) {
        if (event.key === "Enter") {
          sendManualCmd();
        }
      }

      // ============================================================================
      // MAP EDITOR
      // ============================================================================
      function initMapTable() {
        const table = document.getElementById("mapTable");
        const original = mapDataOriginal[currentMapNum] || [];

        // Format RPM for display
        function formatRpm(rpm) {
          if (rpm >= 10000) return (rpm / 1000).toFixed(1) + "k";
          if (rpm >= 1000) return (rpm / 1000).toFixed(1) + "k";
          return rpm.toString();
        }

        // 9x9 grid for 81 RPM points (0-20000 in 250 steps)
        // Each cell shows RPM label clearly
        let html = "<thead><tr><th>RPM</th>";
        for (let col = 0; col < 9; col++) {
          html += `<th>${col + 1}</th>`;
        }
        html += "</tr></thead><tbody>";

        // 9 rows, 9 columns each
        for (let row = 0; row < 9; row++) {
          const startRpm = row * 9 * 250;
          const endRpm = startRpm + 8 * 250;
          html += `<tr><th>${formatRpm(startRpm)}-${formatRpm(endRpm)}</th>`;

          for (let col = 0; col < 9; col++) {
            const idx = row * 9 + col;
            const rpm = idx * 250;
            const val = mapData[currentMapNum][idx] || 0;
            const isChanged =
              original[idx] !== undefined && original[idx] !== val;
            const changedClass = isChanged ? "changed" : "";

            html += `<td><div class="map-cell"><span class="rpm-label">${formatRpm(
              rpm
            )}</span><input type="number" id="map_${idx}" class="${changedClass}" min="-10" max="60" value="${val}" onchange="updateMapValue(${idx}, this.value)" onfocus="highlightRpm(${rpm})"></div></td>`;
          }
          html += "</tr>";
        }
        html += "</tbody>";
        table.innerHTML = html;

        updateChangedCount();
      }

      function updateMapValue(idx, value) {
        mapData[currentMapNum][idx] = parseInt(value);
        // Update input class if changed
        const original = mapDataOriginal[currentMapNum] || [];
        const input = document.getElementById("map_" + idx);
        if (input) {
          const isChanged =
            original[idx] !== undefined &&
            original[idx] !== mapData[currentMapNum][idx];
          input.classList.toggle("changed", isChanged);
        }
        updateChangedCount();
        drawMapCanvas();
      }

      function updateChangedCount() {
        const original = mapDataOriginal[currentMapNum] || [];
        const current = mapData[currentMapNum];
        let count = 0;
        for (let i = 0; i <= 80; i++) {
          if (original[i] !== undefined && original[i] !== current[i]) {
            count++;
          }
        }
        const el = document.getElementById("changedCount");
        if (el) {
          el.textContent = count > 0 ? `(${count})` : "";
        }
      }

      function highlightRpm(rpm) {
        // Could be used to highlight RPM on graph when editing
      }

      function drawMapCanvas() {
        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;

        const w = canvas.width;
        const h = canvas.height;
        const padding = 40;
        const graphW = w - padding * 2;
        const graphH = h - padding * 2;

        // Clear
        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, w, h);

        // Grid
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;

        // Vertical grid (RPM)
        for (let rpm = 0; rpm <= 20000; rpm += 2500) {
          const x = padding + (rpm / 20000) * graphW;
          ctx.beginPath();
          ctx.moveTo(x, padding);
          ctx.lineTo(x, h - padding);
          ctx.stroke();

          ctx.fillStyle = "#666";
          ctx.font = "10px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(rpm.toString(), x, h - padding + 15);
        }

        // Horizontal grid (degrees)
        for (let deg = -10; deg <= 60; deg += 10) {
          const y = h - padding - ((deg + 10) / 70) * graphH;
          ctx.beginPath();
          ctx.moveTo(padding, y);
          ctx.lineTo(w - padding, y);
          ctx.stroke();

          ctx.fillStyle = "#666";
          ctx.font = "10px sans-serif";
          ctx.textAlign = "right";
          ctx.fillText(deg.toString() + "Â°", padding - 5, y + 3);
        }

        // Draw timing curve
        ctx.strokeStyle = "#00d4ff";
        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let i = 0; i <= 80; i++) {
          const rpm = i * 250;
          const timing = mapData[currentMapNum][i];
          const x = padding + (rpm / 20000) * graphW;
          const y = h - padding - ((timing + 10) / 70) * graphH;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // Draw points
        ctx.fillStyle = "#00d4ff";
        for (let i = 0; i <= 80; i++) {
          const rpm = i * 250;
          const timing = mapData[currentMapNum][i];
          const x = padding + (rpm / 20000) * graphW;
          const y = h - padding - ((timing + 10) / 70) * graphH;

          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        // Labels
        ctx.fillStyle = "#00d4ff";
        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("RPM", w / 2, h - 5);

        ctx.save();
        ctx.translate(12, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText("Timing (deg BTDC)", 0, 0);
        ctx.restore();

        // Map title
        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px sans-serif";
        ctx.textAlign = "left";
        ctx.fillText("Map " + currentMapNum, padding, 25);

        // Live RPM indicator (moving dot)
        if (liveRpm > 0 && liveRpm <= 20000) {
          const liveX = padding + (liveRpm / 20000) * graphW;
          const liveY = h - padding - ((liveTiming + 10) / 70) * graphH;

          // Vertical line at current RPM
          ctx.strokeStyle = "rgba(255, 68, 68, 0.5)";
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(liveX, padding);
          ctx.lineTo(liveX, h - padding);
          ctx.stroke();
          ctx.setLineDash([]);

          // Glowing dot at current position
          ctx.beginPath();
          ctx.arc(liveX, liveY, 12, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(255, 68, 68, 0.3)";
          ctx.fill();

          ctx.beginPath();
          ctx.arc(liveX, liveY, 8, 0, Math.PI * 2);
          ctx.fillStyle = "#ff4444";
          ctx.fill();

          ctx.beginPath();
          ctx.arc(liveX, liveY, 4, 0, Math.PI * 2);
          ctx.fillStyle = "#fff";
          ctx.fill();

          // RPM/Timing label
          ctx.fillStyle = "#ff4444";
          ctx.font = "bold 12px sans-serif";
          ctx.textAlign = "right";
          ctx.fillText(liveRpm + " RPM / " + liveTiming + "Â°", w - padding, 25);
        }
      }

      // Canvas click to edit
      document
        .getElementById("mapCanvas")
        .addEventListener("click", function (e) {
          const canvas = this;
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const padding = 40;
          const graphW = canvas.width - padding * 2;
          const graphH = canvas.height - padding * 2;

          // Convert click to RPM/timing
          const rpm =
            Math.round((((x - padding) / graphW) * 20000) / 250) * 250;
          const timing = Math.round(
            ((canvas.height - padding - y) / graphH) * 70 - 10
          );

          if (rpm >= 0 && rpm <= 20000 && timing >= -10 && timing <= 60) {
            const idx = rpm / 250;
            mapData[currentMapNum][idx] = timing;
            document.getElementById("map_" + idx).value = timing;
            drawMapCanvas();
          }
        });

      function loadCurrentMap() {
        sendCmdQueued("MAP " + currentMapNum + " GET");
        showToast("Loading Map " + currentMapNum + "...", "info");
      }

      function setActiveMap() {
        sendCmd("SET MAP=" + currentMapNum);
        showToast("Map " + currentMapNum + " set as active!", "success");
      }

      function uploadCurrentMap() {
        // Only send changed values (diff upload)
        const original = mapDataOriginal[currentMapNum] || [];
        const current = mapData[currentMapNum];
        let changedCount = 0;

        for (let i = 0; i <= 80; i++) {
          if (original[i] !== current[i]) {
            const rpm = i * 250;
            const timing = current[i];
            sendCmdQueued("MAP " + currentMapNum + " " + rpm + " " + timing);
            changedCount++;
          }
        }

        if (changedCount === 0) {
          showToast("No changes to upload", "info");
        } else {
          // Update original after upload
          mapDataOriginal[currentMapNum] = [...current];
          showToast(
            "Uploading " + changedCount + " changed point(s)...",
            "success"
          );
        }
      }

      function copyMap() {
        const data = mapData[currentMapNum];

        // Formatkan agar masuk akal di clipboard (JSON / CSV / plain text)
        const text = JSON.stringify(data);

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast(
              "Map " + currentMapNum + " copied to clipboard",
              "success"
            );
          })
          .catch((err) => {
            console.error(err);
            showToast("Clipboard access failed", "error");
          });
      }

      function pasteMap() {
        if (clipboardMap) {
          mapData[currentMapNum] = [...clipboardMap];
          initMapTable();
          drawMapCanvas();
          showToast("Map pasted to Map " + currentMapNum, "success");
        } else {
          showToast("No map in clipboard", "error");
        }
      }

      function adjustAllTiming(delta) {
        for (let i = 0; i <= 80; i++) {
          mapData[currentMapNum][i] = Math.max(
            -10,
            Math.min(60, mapData[currentMapNum][i] + delta)
          );
          document.getElementById("map_" + i).value = mapData[currentMapNum][i];
        }
        drawMapCanvas();
      }

      function setRange() {
        const start =
          parseInt(document.getElementById("rangeStart").value) || 0;
        const end =
          parseInt(document.getElementById("rangeEnd").value) || 20000;
        const value = parseInt(document.getElementById("rangeValue").value);

        if (isNaN(value)) {
          showToast("Enter a timing value", "error");
          return;
        }

        for (let rpm = start; rpm <= end; rpm += 250) {
          const idx = rpm / 250;
          if (idx >= 0 && idx <= 80) {
            mapData[currentMapNum][idx] = Math.max(-10, Math.min(60, value));
            document.getElementById("map_" + idx).value =
              mapData[currentMapNum][idx];
          }
        }
        drawMapCanvas();
        showToast("Range updated", "success");
      }

      // ============================================================================
      // QUICK SHIFTER MAP
      // ============================================================================
      function initQsMapGrid() {
        const grid = document.getElementById("qsMapGrid");
        if (!grid) return;

        let html = "";
        for (let i = 0; i < 21; i++) {
          const rpm = i * 1000;
          const rpmLabel = rpm >= 1000 ? rpm / 1000 + "k" : rpm;
          const val = qsMapData[i] || 50;
          const isChanged =
            qsMapOriginal[i] !== undefined && qsMapOriginal[i] !== val;
          const changedClass = isChanged ? "changed" : "";

          html += `
                      <div class="qs-map-cell">
                          <div class="rpm-label">${rpmLabel} RPM</div>
                          <input type="number" id="qsmap_${i}" class="${changedClass}"
                                 min="10" max="250" value="${val}"
                                 onchange="updateQsMapValue(${i}, this.value)">
                          <div class="unit">ms</div>
                      </div>`;
        }
        grid.innerHTML = html;
      }

      function updateQsMapValue(idx, value) {
        const val = Math.max(10, Math.min(250, parseInt(value) || 50));
        qsMapData[idx] = val;

        const input = document.getElementById("qsmap_" + idx);
        if (input) {
          input.value = val;
          const isChanged =
            qsMapOriginal[idx] !== undefined && qsMapOriginal[idx] !== val;
          input.classList.toggle("changed", isChanged);
        }
      }

      function loadQsMap() {
        pendingGet.push("QSMAP");
        sendCmdQueued("GET QSMAP");
        showToast("Loading QS Map...", "info");
      }

      function uploadQsMap() {
        // Format: SET QSMAP=v0,v1,v2,...,v20
        const values = qsMapData.join(",");
        sendCmd("SET QSMAP=" + values);
        // Update original to match current (clear changed state)
        qsMapOriginal = [...qsMapData];
        initQsMapGrid();
        showToast("QS Map uploaded", "success");
      }

      // ============================================================================
      // QUICK SHIFTER CALIBRATION
      // ============================================================================
      let qsLiveAdcInterval = null;
      let qsCurrentAdc = 0;

      function updateQsCalibrationDisplay(adc) {
        qsCurrentAdc = adc;
        document.getElementById("qsLiveAdc").textContent = "ADC: " + adc;

        // Update bar (0-4095 range)
        const percent = (adc / 4095) * 100;
        document.getElementById("qsAdcBar").style.width = percent + "%";

        // Update baseline line position
        const baseline =
          parseInt(document.getElementById("setQsBaseline").value) || 2048;
        const baselinePercent = (baseline / 4095) * 100;
        document.getElementById("qsBaselineLine").style.left =
          baselinePercent + "%";

        // Update threshold line position
        const threshold =
          parseInt(document.getElementById("setQsThreshold").value) || 2500;
        const thresholdPercent = (threshold / 4095) * 100;
        document.getElementById("qsThresholdLine").style.left =
          thresholdPercent + "%";

        // Change bar color based on trigger state
        if (adc >= threshold) {
          document.getElementById("qsAdcBar").style.background =
            "linear-gradient(90deg, #ff4444, #ff8800)";
        } else {
          document.getElementById("qsAdcBar").style.background =
            "linear-gradient(90deg, #00d4ff, #ffc800)";
        }
      }

      function qsReadBaseline() {
        // Read current ADC as baseline
        const adc = qsCurrentAdc;
        document.getElementById("setQsBaseline").value = adc;
        updateQsCalibrationDisplay(adc);
        showToast("Baseline set: " + adc, "success");
      }

      function qsCaptureThreshold() {
        // Start capturing mode - find peak ADC value
        showToast("Push shift lever now...", "info");
        let peakAdc = qsCurrentAdc;
        let captureCount = 0;
        const maxCaptures = 50; // 2.5 seconds at 50ms interval

        const captureInterval = setInterval(() => {
          if (qsCurrentAdc > peakAdc) {
            peakAdc = qsCurrentAdc;
          }
          captureCount++;
          if (captureCount >= maxCaptures) {
            clearInterval(captureInterval);
            // Set threshold slightly below peak for reliability
            const threshold = Math.max(
              peakAdc - 50,
              parseInt(document.getElementById("setQsBaseline").value) + 100
            );
            document.getElementById("setQsThreshold").value = threshold;
            updateQsCalibrationDisplay(qsCurrentAdc);
            showToast(
              "Threshold set: " + threshold + " (peak: " + peakAdc + ")",
              "success"
            );
          }
        }, 50);
      }

      // QS ADC now comes from RT data stream automatically (50ms interval)
      // These functions kept for compatibility but no longer needed
      function startQsLiveAdc() {
        // No-op: qsAdc is now in RT data, updated automatically
      }

      function stopQsLiveAdc() {
        // No-op: qsAdc is now in RT data, no polling needed
      }

      // ============================================================================
      // SETTINGS
      // ============================================================================
      let settingsLoading = false;

      function loadAllSettings() {
        if (settingsLoading) return;
        settingsLoading = true;

        // Request all settings from MCU with rate limiting
        sendCmdQueued("GET ENGINE");
        sendCmdQueued("GET TRIGGER");
        sendCmdQueued("GET NOISE");
        sendCmdQueued("GET PULSE");
        sendCmdQueued("GET LIMITER");
        sendCmdQueued("GET SHIFT");
        sendCmdQueued("GET CRANKING");
        sendCmdQueued("GET WARNING");
        sendCmdQueued("GET TEMP_RETARD");
        sendCmdQueued("GET CAL");
        sendCmdQueued("GET QS");

        showToast("Loading settings from MCU...", "info");
        setTimeout(() => {
          settingsLoading = false;
          // Update data source indicator
          const srcEl = document.getElementById("settingsDataSource");
          if (srcEl) {
            srcEl.innerHTML =
              'ðŸ“‚ Data displayed from: <b style="color:#00ff88">MCU (RAM)</b>';
          }
          showToast("Settings loaded from MCU (RAM)", "success");
        }, 1500);
      }

      function saveAllSettings() {
        // Helper to send only if value is not empty
        function setIfValue(param, elementId) {
          const val = document.getElementById(elementId).value;
          if (val !== "" && val !== undefined) {
            sendCmdQueued("SET " + param + "=" + val);
          }
        }

        // Engine
        setIfValue("ENGINE", "setEngineType");

        // Trigger
        setIfValue("TRIGGER_ANGLE", "setTriggerAngle");
        setIfValue("TRIGGER_EDGE", "setTriggerEdge");
        setIfValue("NOISE_FILTER", "setNoiseFilter");
        setIfValue("CDI_PULSE", "setCdiPulse");

        // Rev limiter
        setIfValue("LIMITER_SOFT", "setLimiterSoft");
        setIfValue("LIMITER_MEDIUM", "setLimiterMedium");
        setIfValue("LIMITER_HARD", "setLimiterHard");
        setIfValue("LIMITER_FULLCUT", "setLimiterFull");

        // Shift light
        setIfValue("SHIFT_ON", "setShiftOn");
        setIfValue("SHIFT_BLINK", "setShiftBlink");
        setIfValue("SHIFT_FAST", "setShiftFast");

        // Cranking
        setIfValue("CRANKING_ENABLE", "setCrankingEnable");
        setIfValue("CRANKING_TIMING", "setCrankingTiming");
        setIfValue("CRANKING_RPM", "setCrankingRpm");

        // Warning
        setIfValue("OVERREV_RPM", "setOverrevRpm");
        setIfValue("OVERHEAT_TEMP", "setOverheatTemp");
        setIfValue("LOW_BATTERY", "setLowBattery");
        setIfValue("OVERHEAT_RETARD", "setOverheatRetard");
        setIfValue("RETARD_START", "setRetardStart");
        setIfValue("RETARD_PER10C", "setRetardPer10C");

        // Calibration
        setIfValue("CAL_TEMP_OFFSET", "setCalTempOffset");
        setIfValue("CAL_TEMP_SCALE", "setCalTempScale");
        setIfValue("CAL_BATT_SCALE", "setCalBattScale");
        setIfValue("CAL_CHARGING_SCALE", "setCalChargingScale");

        // Quick Shifter - send as single command
        const qsEnabled =
          document.getElementById("setQsEnable").value === "ON" ? 1 : 0;
        const qsBaseline =
          document.getElementById("setQsBaseline").value || 2048;
        const qsThreshold =
          document.getElementById("setQsThreshold").value || 2500;
        const qsMinRpm = document.getElementById("setQsMinRpm").value || 3000;
        const qsMaxRpm = document.getElementById("setQsMaxRpm").value || 15000;
        const qsSensitivity =
          document.getElementById("setQsSensitivity").value || 10;
        sendCmdQueued(
          `SET QS=${qsEnabled},${qsBaseline},${qsThreshold},${qsMinRpm},${qsMaxRpm},${qsSensitivity}`
        );

        showToast("Settings applied to MCU", "success");
      }

      function saveToSD() {
        sendCmdQueued("SAVE");
        showToast("Saving to SD card...", "info");
      }

      // ============================================================================
      // AUTO CALIBRATION
      // Range: Temperature 0-500Â°C, Voltage 0-30V
      // ============================================================================
      // RAW ADC values now come from RT data automatically
      let lastRawTemp = 0;
      let lastRawBatt = 0;
      let lastRawCharging = 0;

      // Update raw ADC display (called from updateUI when RT data arrives)
      function updateRawAdcDisplay(tempRaw, battRaw, chrgRaw) {
        lastRawTemp = tempRaw;
        lastRawBatt = battRaw;
        lastRawCharging = chrgRaw;
        const el = document.getElementById("rawAdcValues");
        if (el) {
          el.textContent = `T:${tempRaw} B:${battRaw} C:${chrgRaw}`;
        }
      }

      function autoCalibrateVoltage(type) {
        // Firmware formula: V(x100) = raw * 330 * scale / (4095 * 1000)
        // To find scale: scale = actualVoltage * 100 * 4095 * 1000 / (raw * 330)
        //                scale = actualVoltage * 4095000 * 100 / (raw * 330)
        //                scale = actualVoltage * 1240909 / raw (approx)

        let actualVoltage, rawValue, scaleField;

        if (type === "batt") {
          actualVoltage = parseFloat(
            document.getElementById("actualBattVoltage").value
          );
          rawValue = lastRawBatt;
          scaleField = "setCalBattScale";
        } else {
          actualVoltage = parseFloat(
            document.getElementById("actualChargingVoltage").value
          );
          rawValue = lastRawCharging;
          scaleField = "setCalChargingScale";
        }

        if (!actualVoltage || actualVoltage <= 0 || actualVoltage > 30) {
          showToast("Masukkan nilai voltage aktual (0-30V)", "error");
          return;
        }
        if (rawValue <= 0) {
          showToast("Belum ada data RAW ADC, tunggu koneksi", "error");
          return;
        }

        // Calculate scale factor
        // V(x100) = raw * 330 * scale / (4095 * 1000)
        // scale = V * 100 * 4095 * 1000 / (raw * 330)
        const scale = Math.round(
          (actualVoltage * 100 * 4095 * 1000) / (rawValue * 330)
        );
        document.getElementById(scaleField).value = scale;

        showToast(
          `${type === "batt" ? "Battery" : "Charging"} scale = ${scale}`,
          "success"
        );
      }

      function autoCalibrateTemp() {
        // Firmware formula: temp(x10) = raw * scale / 4096 + offset
        // To find offset: offset = actualTemp * 10 - (raw * scale / 4096)

        const actualTemp = parseFloat(
          document.getElementById("actualTemp").value
        );
        const rawValue = lastRawTemp;
        const currentScale =
          parseInt(document.getElementById("setCalTempScale").value) || 5001;

        if (isNaN(actualTemp) || actualTemp < 0 || actualTemp > 500) {
          showToast("Masukkan nilai temperature aktual (0-500Â°C)", "error");
          return;
        }
        if (rawValue <= 0) {
          showToast("Belum ada data RAW ADC, tunggu koneksi", "error");
          return;
        }

        // Calculate offset based on new firmware formula
        // temp(x10) = raw * scale / 4096 + offset
        // offset = actualTemp * 10 - (raw * scale / 4096)
        const scaledValue = Math.round((rawValue * currentScale) / 4096);
        const offset = Math.round(actualTemp * 10 - scaledValue);

        document.getElementById("setCalTempOffset").value = offset;
        showToast(
          `Temp offset = ${offset} (raw=${rawValue}, scale=${currentScale})`,
          "success"
        );
      }

      // ============================================================================
      // FILE MANAGER
      // ============================================================================
      let currentFilePath = "/racing-cdi";
      let currentViewingFile = "";
      let fileBuffer = [];
      let fileExpecting = null; // 'LS', 'CAT', 'DISK', etc.

      function refreshFiles() {
        // Clear log expecting to prevent response interception conflict
        logExpecting = null;
        fileExpecting = "LS";
        fileBuffer = [];
        document.getElementById("fileList").innerHTML =
          '<div class="file-item file-loading">Loading...</div>';
        sendCmd("LS " + currentFilePath);
        sendCmd("DISK");
      }

      function navigateUp() {
        if (currentFilePath === "/" || currentFilePath === "/racing-cdi") {
          currentFilePath = "/";
        } else {
          const parts = currentFilePath.split("/");
          parts.pop();
          currentFilePath = parts.join("/") || "/";
        }
        document.getElementById("currentPath").textContent = currentFilePath;
        refreshFiles();
      }

      function navigateTo(path) {
        currentFilePath = path;
        document.getElementById("currentPath").textContent = currentFilePath;
        refreshFiles();
      }

      function reinitSD() {
        showToast("Reinitializing SD...", "info");
        sendCmd("SDINIT");
      }

      function resetMCU() {
        if (
          !confirm(
            "Reset MCU? This will restart the device and fix SD card issues."
          )
        ) {
          return;
        }
        showToast("Resetting MCU...", "info");
        sendCmd("RESET");
      }

      // File upload state
      let uploadInProgress = false;
      let uploadLines = [];
      let uploadLineIndex = 0;
      let uploadFileName = "";

      function uploadFile(input) {
        if (!input.files || input.files.length === 0) return;

        const file = input.files[0];
        uploadFileName = file.name;

        // Check file size (max 100KB for text files)
        if (file.size > 100 * 1024) {
          showToast("File too large (max 100KB)", "error");
          input.value = "";
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          const content = e.target.result;
          uploadLines = content.split("\n");

          // Start upload
          const destPath = currentFilePath + "/" + uploadFileName;
          showToast("Uploading " + uploadFileName + "...", "info");
          uploadInProgress = true;
          uploadLineIndex = 0;

          sendCmd("UPLOAD " + destPath);
        };

        reader.onerror = function () {
          showToast("Failed to read file", "error");
        };

        reader.readAsText(file);
        input.value = ""; // Reset input
      }

      function continueUpload() {
        if (!uploadInProgress) return;

        // Send lines in chunks to avoid flooding
        const chunkSize = 10;
        for (
          let i = 0;
          i < chunkSize && uploadLineIndex < uploadLines.length;
          i++
        ) {
          sendCmd(uploadLines[uploadLineIndex]);
          uploadLineIndex++;
        }

        if (uploadLineIndex >= uploadLines.length) {
          // All lines sent, end upload
          sendCmd("UPLOAD:END");
        } else {
          // More lines to send
          setTimeout(continueUpload, 50);
        }
      }

      function viewFile(path, size) {
        currentViewingFile = path;
        fileExpecting = "CAT";
        fileBuffer = [];
        document.getElementById("viewerFileName").textContent = path
          .split("/")
          .pop();
        document.getElementById("viewerFileSize").textContent =
          formatFileSize(size);
        document.getElementById("fileContent").textContent = "Loading...";
        document.getElementById("fileViewerHeader").style.display = "flex";
        sendCmd("CAT " + path + " 500"); // Max 500 lines
      }

      function closeViewer() {
        document.getElementById("fileViewerHeader").style.display = "none";
        document.getElementById("fileContent").innerHTML =
          '<div class="file-viewer-empty"><span class="icon">ðŸ“„</span><span>Select a file to view</span></div>';
        currentViewingFile = "";
      }

      function clearConsole() {
        document.getElementById("consoleOutput").innerHTML = "";
      }

      // Download state
      let downloadInProgress = false;
      let downloadBuffer = [];
      let downloadFileName = "";
      let downloadFilePath = "";

      function downloadCurrentFile() {
        if (!currentViewingFile) {
          showToast("No file selected", "error");
          return;
        }

        if (downloadInProgress) {
          showToast("Download already in progress", "warning");
          return;
        }

        // Start download - request full file with 0 (unlimited)
        downloadInProgress = true;
        downloadBuffer = [];
        downloadFilePath = currentViewingFile;
        downloadFileName = currentViewingFile.split("/").pop();

        showToast("Downloading " + downloadFileName + "...", "info");
        sendCmd("CAT " + currentViewingFile + " 0");
      }

      function processDownload(text) {
        if (!downloadInProgress) return false;

        if (text.startsWith("CAT:") && !text.startsWith("CAT:END")) {
          // CAT:path,size - start of file
          return true;
        }

        if (text === "CAT:END") {
          // Download complete - create file
          const content = downloadBuffer.join("\n");
          const blob = new Blob([content], { type: "text/plain" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = downloadFileName;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          showToast(
            "Downloaded " +
              downloadFileName +
              " (" +
              downloadBuffer.length +
              " lines)",
            "success"
          );
          downloadInProgress = false;
          downloadBuffer = [];
          return true;
        }

        if (
          text === "CAT:BUSY" ||
          text === "CAT:NOTFOUND" ||
          text === "CAT:ERROR"
        ) {
          showToast("Download failed: " + text, "error");
          downloadInProgress = false;
          downloadBuffer = [];
          return true;
        }

        if (text === "...TRUNCATED") {
          // File was truncated, still save what we have
          return true;
        }

        // File content line
        downloadBuffer.push(text);
        return true;
      }

      function deleteFile(path) {
        if (confirm("Delete " + path + "?")) {
          sendCmd("RM " + path);
          setTimeout(refreshFiles, 300);
        }
      }

      function deleteCurrentFile() {
        if (
          currentViewingFile &&
          confirm("Delete " + currentViewingFile + "?")
        ) {
          sendCmd("RM " + currentViewingFile);
          closeViewer();
          setTimeout(refreshFiles, 300);
        }
      }

      function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
        return (bytes / (1024 * 1024)).toFixed(2) + " MB";
      }

      function handleFileResponse(text) {
        // Handle DISK response: SD:OK or SD:ERROR
        if (text.startsWith("SD:")) {
          const statusEl = document.getElementById("diskStatus");
          const dashStatus = document.getElementById("dashSdStatus");

          if (text === "SD:OK") {
            statusEl.textContent = "OK";
            statusEl.style.color = "#00c853";
            // Update dashboard
            dashStatus.textContent = "OK";
            dashStatus.style.color = "#00c853";
          } else if (text === "SD:ERROR") {
            statusEl.textContent = "ERROR";
            statusEl.style.color = "#ff4444";
            dashStatus.textContent = "ERROR";
            dashStatus.style.color = "#ff4444";
          }
          return true;
        }

        // Handle SDINIT response
        if (text.startsWith("SDINIT:")) {
          if (text === "SDINIT:OK") {
            showToast("SD card reinitialized!", "success");
            refreshFiles();
          } else if (text === "SDINIT:FAIL") {
            showToast("SD reinit failed - try Reset MCU", "error");
          } else if (text === "SDINIT:BUSY") {
            showToast("Stop engine first!", "warning");
          }
          return true;
        }

        // Handle RESET response
        if (text.startsWith("RESET:")) {
          if (text === "RESET:OK") {
            showToast("MCU resetting...", "info");
            // Connection will be lost, UI will show disconnected
          } else if (text === "RESET:BUSY") {
            showToast("Stop engine to reset MCU", "error");
          }
          return true;
        }

        // Ignore intermediate reinit messages
        if (text === "SD begin..." || text.startsWith("SD init failed")) {
          return true;
        }

        // Handle Reinit SD messages from auto-reinit
        if (text === "Reinit SD..." || text.startsWith("Use RESET command")) {
          return true; // Ignore, just logging
        }
        if (text === "SD reinit OK" || text === "SD reinit failed") {
          return true; // Handled by SDINIT response
        }

        // Handle UPLOAD responses
        if (text.startsWith("UPLOAD:")) {
          if (text.startsWith("UPLOAD:READY")) {
            // MCU ready, start sending data
            continueUpload();
          } else if (text.startsWith("UPLOAD:OK")) {
            // Upload complete
            const bytes = text.split(",")[1] || "0";
            showToast(
              "Uploaded " + uploadFileName + " (" + bytes + " bytes)",
              "success"
            );
            uploadInProgress = false;
            uploadLines = [];
            refreshFiles();
          } else if (text === "UPLOAD:BUSY") {
            showToast("Stop engine to upload files", "error");
            uploadInProgress = false;
          } else if (text === "UPLOAD:SDERROR") {
            showToast("SD card error", "error");
            uploadInProgress = false;
          } else if (text === "UPLOAD:OPENFAIL") {
            showToast("Failed to create file", "error");
            uploadInProgress = false;
          } else if (text === "UPLOAD:CANCELLED") {
            showToast("Upload cancelled", "info");
            uploadInProgress = false;
          }
          return true;
        }

        // Handle LS response
        if (text.startsWith("LS:")) {
          if (text === "LS:END") {
            renderFileList();
            fileExpecting = null;
          } else if (text === "LS:BUSY") {
            document.getElementById("fileList").innerHTML =
              '<div class="file-item file-loading">Engine running - stop engine to browse files</div>';
            showToast("Stop engine to browse SD card", "error");
          } else if (text === "LS:NOTFOUND" || text === "LS:ERROR") {
            document.getElementById("fileList").innerHTML =
              '<div class="file-item file-loading">Directory not found or error</div>';
            fileExpecting = null;
          } else {
            // LS:/path - start of listing
            fileBuffer = [];
          }
          return true;
        }

        // Handle file entries during LS
        if (
          fileExpecting === "LS" &&
          (text.startsWith("D:") || text.startsWith("F:"))
        ) {
          fileBuffer.push(text);
          return true;
        }

        // Handle CAT response
        if (text.startsWith("CAT:")) {
          if (text === "CAT:END") {
            document.getElementById("fileContent").textContent =
              fileBuffer.join("\n");
            fileBuffer = [];
            fileExpecting = null;
          } else if (text === "CAT:BUSY") {
            document.getElementById("fileContent").textContent =
              "Engine running - stop engine to view files";
            showToast("Stop engine to view files", "error");
          } else if (text === "CAT:NOTFOUND" || text === "CAT:ERROR") {
            document.getElementById("fileContent").textContent =
              "Error reading file";
            fileExpecting = null;
          } else {
            // CAT:/path,size - start of file content
            fileBuffer = [];
            fileExpecting = "CAT_CONTENT";
          }
          return true;
        }

        // Collect file content
        if (fileExpecting === "CAT_CONTENT") {
          if (text === "CAT:END") {
            document.getElementById("fileContent").textContent =
              fileBuffer.join("\n");
            fileBuffer = [];
            fileExpecting = null;
          } else if (text === "...TRUNCATED") {
            fileBuffer.push(
              "\n... [File truncated - too large to display] ..."
            );
          } else {
            fileBuffer.push(text);
          }
          return true;
        }

        // Handle RM response
        if (text.startsWith("RM:")) {
          if (text === "RM:OK") {
            showToast("File deleted", "success");
          } else if (text === "RM:BUSY") {
            showToast("Stop engine to delete files", "error");
          } else {
            showToast("Delete failed: " + text, "error");
          }
          return true;
        }

        // Handle EXPORT response
        if (text.startsWith("EXPORT:")) {
          if (text === "EXPORT:BUSY") {
            showToast("Stop engine (RPM < 100) to export", "error");
          }
          return true;
        }

        // Handle IMPORT response
        if (text.startsWith("IMPORT:")) {
          if (text === "IMPORT:BUSY") {
            showToast("Stop engine (RPM < 100) to import", "error");
          }
          return true;
        }

        // Handle SAVE response
        if (text.startsWith("SAVE:")) {
          if (text === "SAVE:BUSY") {
            showToast("Stop engine (RPM < 100) to save", "error");
          }
          return true;
        }

        // Handle LOAD response
        if (text.startsWith("LOAD:")) {
          if (text === "LOAD:BUSY") {
            showToast("Stop engine (RPM < 100) to load", "error");
          }
          return true;
        }

        // Handle IGN response
        if (text.startsWith("IGN:")) {
          if (text === "IGN:ON") {
            updateIgnitionButton(true);
          } else if (text === "IGN:OFF") {
            updateIgnitionButton(false);
          }
          return true;
        }

        return false;
      }

      function renderFileList() {
        const listEl = document.getElementById("fileList");

        if (fileBuffer.length === 0) {
          listEl.innerHTML =
            '<div class="file-item file-loading">Empty directory</div>';
          return;
        }

        // Sort: directories first, then files
        // Filter out .bin files from display (format: F:name,size)
        const dirs = fileBuffer.filter((f) => f.startsWith("D:"));
        const files = fileBuffer.filter((f) => {
          if (!f.startsWith("F:")) return false;
          const name = f.substring(2).split(",")[0].toLowerCase();
          return !name.endsWith(".bin");
        });

        let html = "";

        // Directories
        dirs.forEach((entry) => {
          const name = entry.substring(2);
          const fullPath = currentFilePath + "/" + name;
          html += `<div class="file-item directory" onclick="navigateTo('${fullPath}')">
                          <span class="file-icon">[D]</span>
                          <span class="file-name">${name}</span>
                      </div>`;
        });

        // Files
        files.forEach((entry) => {
          const parts = entry.substring(2).split(",");
          const name = parts[0];
          const size = parseInt(parts[1]) || 0;
          const fullPath = currentFilePath + "/" + name;
          html += `<div class="file-item file" onclick="viewFile('${fullPath}', ${size})">
                          <span class="file-icon">[F]</span>
                          <span class="file-name">${name}</span>
                          <span class="file-size">${formatFileSize(size)}</span>
                          <div class="file-actions">
                              <button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); deleteFile('${fullPath}')">Del</button>
                          </div>
                      </div>`;
        });

        listEl.innerHTML = html;
      }

      // ============================================================================
      // DASHBOARD HELPERS
      // ============================================================================
      function loadDashboardInfo() {
        // Load system info for dashboard
        sendCmdQueued("GET ENGINE");
        sendCmdQueued("GET TRIGGER");
        sendCmdQueued("DISK");
        sendCmdQueued("IGN"); // Get ignition status
      }

      function confirmResetPeak() {
        if (confirm("Reset Peak RPM to 0?")) {
          sendCmd("RESETPEAK");
          showToast("Peak RPM reset", "success");
        }
      }

      // Track current ignition state
      let ignitionState = true;

      function toggleIgnition() {
        if (ignitionState) {
          // Currently ON, turn OFF
          if (
            confirm("Matikan pengapian?\nMesin akan mati jika sedang berjalan.")
          ) {
            sendCmd("IGN OFF");
            showToast("Pengapian dimatikan", "warning");
          }
        } else {
          // Currently OFF, turn ON
          sendCmd("IGN ON");
          showToast("Pengapian diaktifkan", "success");
        }
      }

      function updateIgnitionButton(enabled) {
        ignitionState = enabled;
        const btn = document.getElementById("btnIgnition");
        const btn2 = document.getElementById("btnIgnition2");
        const label = document.getElementById("ignitionLabel");
        const hint = document.getElementById("ignitionHint");

        if (enabled) {
          btn.className = "btn btn-lg ignition-btn active";
          label.textContent = "AKTIF";
          hint.textContent = "Klik untuk matikan pengapian";
          // Update map editor button
          if (btn2) {
            btn2.className = "btn btn-success btn-sm";
            btn2.textContent = "IGN ON";
          }
        } else {
          btn.className = "btn btn-lg ignition-btn inactive";
          label.textContent = "MATI";
          hint.textContent = "Klik untuk aktifkan pengapian";
          // Update map editor button
          if (btn2) {
            btn2.className = "btn btn-danger btn-sm";
            btn2.textContent = "IGN OFF";
          }
        }
      }

      function confirmResetDefault() {
        if (
          confirm(
            "Reset ALL settings to default?\n\nThis will load your custom defaults if set,\nor factory defaults if not."
          )
        ) {
          sendCmd("DEFAULT");
          showToast("Settings reset to default", "success");
          // Reload settings after reset
          setTimeout(loadAllSettings, 500);
          setTimeout(checkDefaultsStatus, 600);
        }
      }

      // ============================================================================
      // FLASH DEFAULTS (Settings + Safety Map stored separately)
      // ============================================================================
      // Flash flags: 0x01=settings, 0x02=map, 0x04=QS
      let flashFlags = 0;
      let defaultsWriteCount = 0;
      let defaultsSourceMap = 0; // Which map is stored in Flash (0 = none)

      // Settings tab: Save/Load basic settings only (NOT QS)
      function confirmSaveSettings() {
        const warning = `âš ï¸ SAVE SETTINGS TO FLASH âš ï¸

      This will store current settings to internal Flash:
      â€¢ Trigger config, Rev limiter, Shift light
      â€¢ ADC calibration, Cranking, Warnings, Engine type

      NOT included (save separately):
      â€¢ Quick Shifter config (use QS tab)
      â€¢ Ignition Maps (use Map Editor)

      Flash writes: ${defaultsWriteCount}/10000

      Save settings to Flash?`;

        if (confirm(warning)) {
          sendCmd("SAVESETTINGS");
          showToast("Saving settings to Flash...", "info");
        }
      }

      function confirmLoadSettings() {
        const hasSettings = (flashFlags & 0x01) !== 0;
        if (!hasSettings) {
          showToast("No settings in Flash", "error");
          return;
        }

        // READ ONLY: Display Flash settings in UI (does NOT overwrite MCU config)
        // User can edit the displayed values and save back to Flash
        sendCmd("GET FLASHSETTINGS");
        showToast("Reading Flash settings...", "info");
      }

      // QS tab: Save/Load QS config + cut time map only
      function confirmSaveQS() {
        const warning = `âš ï¸ SAVE QS CONFIG TO FLASH âš ï¸

      This will store Quick Shifter config to internal Flash:
      â€¢ Enabled, Sensitivity, Baseline, Threshold
      â€¢ Min/Max RPM, Cut Time Map (21 points)

      Flash writes: ${defaultsWriteCount}/10000

      Save QS config to Flash?`;

        if (confirm(warning)) {
          sendCmd("SAVEQS");
          showToast("Saving QS config to Flash...", "info");
        }
      }

      function confirmLoadQS() {
        const hasQS = (flashFlags & 0x04) !== 0;
        if (!hasQS) {
          showToast("No QS config in Flash", "error");
          return;
        }

        // READ ONLY: Display Flash QS config in UI (does NOT overwrite MCU config)
        // User can edit the displayed values and save back to Flash
        sendCmd("GET FLASHQS");
        sendCmd("GET FLASHQSMAP");
        showToast("Reading Flash QS config...", "info");
      }

      // Map Editor: Save/Load map only
      function confirmSaveMap() {
        const mapToSave = currentMapNum;

        const warning = `âš ï¸ SAVE MAP ${mapToSave} AS SAFETY MAP âš ï¸

      This will store Map ${mapToSave} to internal Flash.
      When SD card fails, this map will be used for ALL maps.

      IMPORTANT:
      â€¢ Flash has ~10,000 write cycles
      â€¢ Current writes: ${defaultsWriteCount}/10000
      â€¢ Settings are NOT included (use Settings tab)

      Save Map ${mapToSave} to Flash?`;

        if (confirm(warning)) {
          sendCmd("SAVEMAP " + mapToSave);
          showToast("Saving Map " + mapToSave + " to Flash...", "info");
        }
      }

      function confirmLoadMap() {
        const hasMap = (flashFlags & 2) !== 0;
        if (!hasMap) {
          showToast("No safety map in Flash", "error");
          return;
        }

        // READ ONLY: Display Flash safety map in UI (does NOT overwrite MCU config)
        // User can edit the displayed values and save back to Flash
        sendCmd("GET FLASHMAP");
        showToast("Reading Flash safety map...", "info");
      }

      function confirmClearDefaults() {
        if (
          confirm(
            "Clear ALL Flash defaults?\n\nBoth settings and safety map will be erased.\nCurrent config will NOT be affected."
          )
        ) {
          sendCmd("CLEARDEFAULT");
          showToast("Flash cleared", "success");
          setTimeout(checkDefaultsStatus, 500);
        }
      }

      function checkDefaultsStatus() {
        sendCmd("GET DEFAULTS");
      }

      function resolvePending(cmd) {
        const i = pendingGet.indexOf(cmd);
        if (i !== -1) pendingGet.splice(i, 1);
      }

      // Handle DEFAULTS response: DEFAULTS:flags,writeCount,sourceMap
      function handleDefaultsResponse(text) {
        if (!text.startsWith("DEFAULTS:")) return false;
        resolvePending("DEFAULTS");
        const parts = text.substring(9).split(",");
        flashFlags = parseInt(parts[0]) || 0;
        defaultsWriteCount = parseInt(parts[1]) || 0;
        defaultsSourceMap = parseInt(parts[2]) || 0;

        const statusEl = document.getElementById("defaultsStatus");
        if (statusEl) {
          let status = [];
          if (flashFlags & 0x01)
            status.push('<span style="color:#00d4ff;">Settings</span>');
          if (flashFlags & 0x04)
            status.push('<span style="color:#ffaa00;">QS</span>');
          if (flashFlags & 0x02)
            status.push(
              `<span style="color:#00ff88;">Map ${defaultsSourceMap}</span>`
            );

          if (status.length > 0) {
            statusEl.innerHTML = `Flash: ${status.join(
              " + "
            )} (${defaultsWriteCount} writes)`;
          } else {
            statusEl.innerHTML = `Flash: <span style="color:#888;">Empty</span>`;
          }
        }
        return true;
      }

      function exportConfig() {
        sendCmd("EXPORT");
        showToast("Exporting config to text files on SD card...", "info");
      }

      function importConfig() {
        if (
          confirm(
            'Import config from text files on SD card?\nThis will overwrite current settings in MCU memory.\nUse "Save to SD" to make changes permanent.'
          )
        ) {
          sendCmd("IMPORT");
          showToast("Importing config from text files...", "info");
          // Reload settings after import
          setTimeout(loadAllSettings, 1000);
        }
      }

      // ============================================================================
      // LOG VIEWER
      // ============================================================================
      let logFiles = [];
      let logExpecting = null;
      let logBuffer = [];
      let currentLogFile = "";

      function refreshLogList() {
        // Clear file expecting to prevent response interception conflict
        fileExpecting = null;
        logExpecting = "LOG_LS";
        logFiles = [];
        sendCmd("LS /racing-cdi");
      }

      function loadLatestLog() {
        // Find the latest log file (highest number)
        if (logFiles.length === 0) {
          // First refresh the list, then load
          fileExpecting = null;  // Clear file expecting
          logExpecting = "LOG_LS_THEN_LATEST";
          sendCmd("LS /racing-cdi");
          return;
        }
        loadLatestLogFile();
      }

      function loadLatestLogFile() {
        const logs = logFiles.filter(
          (f) => f.name.startsWith("log_") && f.name.endsWith(".csv")
        );
        if (logs.length === 0) {
          showToast("No log files found", "error");
          return;
        }
        // Sort by number in filename
        logs.sort((a, b) => {
          const numA =
            parseInt(a.name.replace("log_", "").replace(".csv", "")) || 0;
          const numB =
            parseInt(b.name.replace("log_", "").replace(".csv", "")) || 0;
          return numB - numA; // Descending
        });
        const latest = logs[0];
        loadLogFile("/racing-cdi/" + latest.name, latest.size);
      }

      function loadSelectedLog() {
        const select = document.getElementById("logFileSelect");
        const val = select.value;
        if (!val) return;

        const parts = val.split("|");
        const path = parts[0];
        const size = parseInt(parts[1]) || 0;
        loadLogFile(path, size);
      }

      function loadLogFile(path, size) {
        currentLogFile = path;
        logExpecting = "LOG_CAT";
        logBuffer = [];

        document.getElementById("logFileName").textContent = path
          .split("/")
          .pop();
        document.getElementById("logFileSize").textContent =
          formatFileSize(size);
        document.getElementById("logTableBody").innerHTML =
          '<tr><td colspan="7" class="log-empty">Loading...</td></tr>';
        document.getElementById("logStats").innerHTML = "";

        // Load last 100 lines (tail)
        sendCmd("CAT " + path + " 200");
      }

      function handleLogResponse(text) {
        // Handle log list response
        if (
          logExpecting === "LOG_LS" ||
          logExpecting === "LOG_LS_THEN_LATEST"
        ) {
          if (text.startsWith("LS:")) {
            if (text === "LS:END") {
              updateLogFileSelect();
              if (logExpecting === "LOG_LS_THEN_LATEST") {
                loadLatestLogFile();
              }
              logExpecting = null;
            } else if (text === "LS:BUSY") {
              showToast("Stop engine to view logs", "error");
              document.getElementById("logTableBody").innerHTML =
                '<tr><td colspan="7" class="log-empty">Engine running - stop engine to view logs</td></tr>';
              logExpecting = null;
            }
            return true;
          }
          if (text.startsWith("F:")) {
            const parts = text.substring(2).split(",");
            const name = parts[0];
            const size = parseInt(parts[1]) || 0;
            if (name.startsWith("log_") && name.endsWith(".csv")) {
              logFiles.push({ name, size });
            }
            return true;
          }
          if (text.startsWith("D:")) {
            return true; // Ignore directories
          }
        }

        // Handle log content
        if (logExpecting === "LOG_CAT") {
          if (text.startsWith("CAT:")) {
            if (text === "CAT:END") {
              renderLogTable();
              logExpecting = null;
            } else if (text === "CAT:BUSY") {
              document.getElementById("logTableBody").innerHTML =
                '<tr><td colspan="7" class="log-empty">Engine running - stop engine to view logs</td></tr>';
              showToast("Stop engine to view logs", "error");
              logExpecting = null;
            } else if (text === "CAT:NOTFOUND" || text === "CAT:ERROR") {
              document.getElementById("logTableBody").innerHTML =
                '<tr><td colspan="7" class="log-empty">Error loading log</td></tr>';
              logExpecting = null;
            } else {
              // CAT:path,size - start
              logBuffer = [];
              logExpecting = "LOG_CAT_CONTENT";
            }
            return true;
          }
        }

        if (logExpecting === "LOG_CAT_CONTENT") {
          if (text === "CAT:END" || text === "...TRUNCATED") {
            if (text === "...TRUNCATED") {
              logBuffer.push("...truncated");
            }
            renderLogTable();
            logExpecting = null;
            return true;
          }
          // Skip header line
          if (!text.startsWith("ms,")) {
            logBuffer.push(text);
          }
          return true;
        }

        return false;
      }

      function updateLogFileSelect() {
        const select = document.getElementById("logFileSelect");
        select.innerHTML = '<option value="">-- Select Log --</option>';

        // Sort logs by number descending
        const logs = [...logFiles].sort((a, b) => {
          const numA =
            parseInt(a.name.replace("log_", "").replace(".csv", "")) || 0;
          const numB =
            parseInt(b.name.replace("log_", "").replace(".csv", "")) || 0;
          return numB - numA;
        });

        logs.forEach((log) => {
          const opt = document.createElement("option");
          opt.value = "/racing-cdi/" + log.name + "|" + log.size;
          opt.textContent = log.name + " (" + formatFileSize(log.size) + ")";
          select.appendChild(opt);
        });

        // Update dashboard log count
        document.getElementById("dashLogCount").textContent =
          logs.length > 0 ? logs.length : "0";
      }

      function renderLogTable() {
        const tbody = document.getElementById("logTableBody");

        if (logBuffer.length === 0) {
          tbody.innerHTML =
            '<tr><td colspan="7" class="log-empty">No data in log</td></tr>';
          document.getElementById("logStats").innerHTML = "";
          return;
        }

        // Parse CSV: ms,rpm,timing,temp,batt,map,lim,flags
        let html = "";
        let maxRpm = 0,
          maxTemp = 0,
          minBatt = 999;
        let totalRows = 0;

        // Show last 50 rows (reverse order - newest first)
        const rows = logBuffer.slice(-50).reverse();

        rows.forEach((line) => {
          if (line === "...truncated") return;
          const parts = line.split(",");
          if (parts.length >= 7) {
            const ms = parseInt(parts[0]) || 0;
            const rpm = parseInt(parts[1]) || 0;
            const timing = parseInt(parts[2]) || 0;
            const temp = parseInt(parts[3]) || 0;
            const batt = parseFloat(parts[4]) || 0;
            const map = parseInt(parts[5]) || 1;
            const lim = parseInt(parts[6]) || 0;

            // Format time as mm:ss.ms
            const mins = Math.floor(ms / 60000);
            const secs = Math.floor((ms % 60000) / 1000);
            const msec = ms % 1000;
            const timeStr =
              mins.toString().padStart(2, "0") +
              ":" +
              secs.toString().padStart(2, "0") +
              "." +
              Math.floor(msec / 100);

            // Color coding
            const rpmClass =
              rpm > 10000
                ? 'style="color:#ff4444"'
                : rpm > 8000
                ? 'style="color:#ffaa00"'
                : "";
            const tempClass = temp > 100 ? 'style="color:#ff4444"' : "";
            const battClass = batt < 11 ? 'style="color:#ff4444"' : "";
            const limClass = lim > 0 ? 'style="color:#ff4444"' : "";

            html += `<tr>
                              <td>${timeStr}</td>
                              <td ${rpmClass}>${rpm}</td>
                              <td>${timing}Â°</td>
                              <td ${tempClass}>${temp}Â°C</td>
                              <td ${battClass}>${batt}V</td>
                              <td>${map}</td>
                              <td ${limClass}>${lim}</td>
                          </tr>`;

            // Stats
            if (rpm > maxRpm) maxRpm = rpm;
            if (temp > maxTemp) maxTemp = temp;
            if (batt > 0 && batt < minBatt) minBatt = batt;
            totalRows++;
          }
        });

        tbody.innerHTML =
          html ||
          '<tr><td colspan="7" class="log-empty">No valid data</td></tr>';

        // Show stats
        if (totalRows > 0) {
          document.getElementById("logStats").innerHTML = `
                          <div class="log-stat"><span class="log-stat-label">Entries:</span><span class="log-stat-value">${
                            logBuffer.length
                          }</span></div>
                          <div class="log-stat"><span class="log-stat-label">Max RPM:</span><span class="log-stat-value">${maxRpm}</span></div>
                          <div class="log-stat"><span class="log-stat-label">Max Temp:</span><span class="log-stat-value">${maxTemp}Â°C</span></div>
                          <div class="log-stat"><span class="log-stat-label">Min Batt:</span><span class="log-stat-value">${minBatt.toFixed(
                            1
                          )}V</span></div>
                      `;
        }
      }

      // ============================================================================
      // CONSOLE
      // ============================================================================
      function logConsole(msg, type = "resp") {
        const consoleEl = document.getElementById("consoleOutput");
        const line = document.createElement("div");
        line.className = "console-line " + type;
        line.textContent = msg;
        consoleEl.appendChild(line);
        consoleEl.scrollTop = consoleEl.scrollHeight;

        // Limit lines
        while (consoleEl.children.length > 500) {
          consoleEl.removeChild(consoleEl.firstChild);
        }
      }

      // ============================================================================
      // TOAST
      // ============================================================================
      let toastTimer = null;
      function showToast(msg, type = "info", duration = 3000) {
        const toast = document.getElementById("toast");
        toast.textContent = msg;
        toast.className = "toast " + type + " show";

        // Clear previous timer
        if (toastTimer) {
          clearTimeout(toastTimer);
          toastTimer = null;
        }

        // Auto-hide after duration (0 = stay visible)
        if (duration > 0) {
          toastTimer = setTimeout(() => {
            toast.classList.remove("show");
          }, duration);
        }
      }

      // ============================================================================
      // TAB NAVIGATION
      // ============================================================================
      document.querySelectorAll(".tab-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document
            .querySelectorAll(".tab-btn")
            .forEach((b) => b.classList.remove("active"));
          document
            .querySelectorAll(".tab-content")
            .forEach((c) => c.classList.remove("active"));

          btn.classList.add("active");
          document.getElementById(btn.dataset.tab).classList.add("active");

          // Stop QS live ADC polling when leaving settings tab
          stopQsLiveAdc();

          // Redraw graphs when switching to dashboard tab
          if (btn.dataset.tab === "dashboard") {
            setTimeout(initGraphs, 50);
          }

          // Auto-load when switching to maps tab + init scope
          if (btn.dataset.tab === "maps") {
            loadCurrentMap();
            setTimeout(initScopeCanvas, 50);
          }

          // Auto-load settings when switching to settings tab
          if (btn.dataset.tab === "settings") {
            loadAllSettings();
            startQsLiveAdc(); // Start live ADC polling for QS calibration
          }

          // Auto-load files when switching to files tab
          if (btn.dataset.tab === "files") {
            refreshFiles();
          }
        });
      });

      // Map tab buttons - auto load from MCU when switching maps
      document.querySelectorAll(".map-tab").forEach((btn) => {
        btn.addEventListener("click", () => {
          document
            .querySelectorAll(".map-tab")
            .forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentMapNum = parseInt(btn.dataset.mapnum);
          // Auto load map from MCU
          loadCurrentMap();
        });
      });

      // Map button click handlers (dashboard)
      document.querySelectorAll(".map-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          sendCmd("SET MAP=" + btn.dataset.map);
        });
      });

      // ============================================================================
      // OSCILLOSCOPE
      // ============================================================================
      let scopeData = {
        rpm: 0,
        timing: 0, // Timing in degrees BTDC
        triggerAngle: 0, // Trigger position BTDC
        cut: 0, // 1 = cut by limiter
        limiter: 0, // Limiter stage 0-4
        engineType: 2, // 2 = 2-stroke, 4 = 4-stroke
      };
      let scopeCtx1 = null;
      let scopeCtx2 = null;

      function initScopeCanvas() {
        const canvas1 = document.getElementById("scopeCh1");
        const canvas2 = document.getElementById("scopeCh2");

        if (canvas1 && canvas2) {
          // Set canvas resolution
          const rect1 = canvas1.getBoundingClientRect();
          const rect2 = canvas2.getBoundingClientRect();

          canvas1.width = rect1.width * window.devicePixelRatio;
          canvas1.height = rect1.height * window.devicePixelRatio;
          canvas2.width = rect2.width * window.devicePixelRatio;
          canvas2.height = rect2.height * window.devicePixelRatio;

          scopeCtx1 = canvas1.getContext("2d");
          scopeCtx2 = canvas2.getContext("2d");

          scopeCtx1.scale(window.devicePixelRatio, window.devicePixelRatio);
          scopeCtx2.scale(window.devicePixelRatio, window.devicePixelRatio);

          // Draw initial empty state
          drawScopeGrid(scopeCtx1, rect1.width, rect1.height);
          drawScopeGrid(scopeCtx2, rect2.width, rect2.height);
        }
      }

      function drawScopeGrid(ctx, width, height) {
        // Background
        ctx.fillStyle = "#0a0a0a";
        ctx.fillRect(0, 0, width, height);

        // Grid lines
        ctx.strokeStyle = "#1a1a1a";
        ctx.lineWidth = 1;

        // Vertical grid lines (every 45 degrees for 360Â° view)
        const divisions = 8;
        for (let i = 0; i <= divisions; i++) {
          const x = (width / divisions) * i;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }

        // Horizontal center line
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();

        // Brighter TDC line (center for 2-stroke view)
        ctx.strokeStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, height);
        ctx.stroke();
      }

      function drawScope() {
        const canvas1 = document.getElementById("scopeCh1");
        const canvas2 = document.getElementById("scopeCh2");

        if (!canvas1 || !canvas2 || !scopeCtx1 || !scopeCtx2) {
          initScopeCanvas();
          if (!scopeCtx1 || !scopeCtx2) return;
        }

        const rect1 = canvas1.getBoundingClientRect();
        const rect2 = canvas2.getBoundingClientRect();
        const w = rect1.width;
        const h = rect1.height;

        // Cycle degrees (360 for 2-stroke, 720 for 4-stroke)
        const cycleDeg = scopeData.engineType === 4 ? 720 : 360;

        // Update info displays
        document.getElementById("scopeCh1Info").textContent =
          scopeData.rpm + " RPM | Trig @ " + scopeData.triggerAngle + "Â° BTDC";
        document.getElementById("scopeCh2Info").textContent =
          "Fire @ " +
          scopeData.timing +
          "Â° | " +
          (scopeData.cut ? "CUT" : "OK") +
          (scopeData.limiter > 0 ? " (L" + scopeData.limiter + ")" : "");

        // Update degree axis for engine type (both columns)
        const axisHtml =
          cycleDeg === 360
            ? "<span>TDC</span><span>90Â°</span><span>180Â°</span><span>270Â°</span><span>360Â°</span>"
            : "<span>TDC</span><span>180Â°</span><span>360Â°</span><span>540Â°</span><span>720Â°</span>";
        const axis1 = document.getElementById("scopeAxis1");
        const axis2 = document.getElementById("scopeAxis2");
        if (axis1) axis1.innerHTML = axisHtml;
        if (axis2) axis2.innerHTML = axisHtml;

        // === DRAW CH1: VR INPUT ===
        drawScopeGrid(scopeCtx1, w, h);

        // Convert trigger angle to X position
        // TDC (0Â°) is at left edge, trigger happens at triggerAngle BTDC
        // For display: angle from TDC = cycleDeg - triggerAngle (for BTDC)
        // Actually, let's display: X=0 is TDC, X increases going away from TDC
        // Trigger at triggerAngle BTDC means it's at position (cycleDeg - triggerAngle)
        const triggerX = ((cycleDeg - scopeData.triggerAngle) / cycleDeg) * w;

        // Draw trigger pulse (rising edge style)
        scopeCtx1.strokeStyle = "#ffff00";
        scopeCtx1.lineWidth = 2;
        scopeCtx1.beginPath();

        // Low line before trigger
        const lowY = h * 0.8;
        const highY = h * 0.2;
        const pulseWidth = w * 0.02; // 2% of width for pulse

        scopeCtx1.moveTo(0, lowY);
        scopeCtx1.lineTo(Math.max(0, triggerX - pulseWidth), lowY);
        // Rising edge
        scopeCtx1.lineTo(triggerX, highY);
        // Short high
        scopeCtx1.lineTo(triggerX + pulseWidth, highY);
        // Falling edge
        scopeCtx1.lineTo(triggerX + pulseWidth * 2, lowY);
        // Low line after
        scopeCtx1.lineTo(w, lowY);
        scopeCtx1.stroke();

        // Trigger marker line (vertical dotted)
        scopeCtx1.strokeStyle = "#ffff00";
        scopeCtx1.setLineDash([4, 4]);
        scopeCtx1.lineWidth = 1;
        scopeCtx1.beginPath();
        scopeCtx1.moveTo(triggerX, 0);
        scopeCtx1.lineTo(triggerX, h);
        scopeCtx1.stroke();
        scopeCtx1.setLineDash([]);

        // === DRAW CH2: IGNITION OUTPUT ===
        drawScopeGrid(scopeCtx2, w, h);

        // Ignition timing position
        // Fire at timingÂ° BTDC = position (cycleDeg - timing)
        const ignX = ((cycleDeg - scopeData.timing) / cycleDeg) * w;

        // Dwell starts about 3-5ms before fire (estimate ~30Â° at mid RPM)
        const dwellDeg = Math.min(30, scopeData.timing - 5); // Don't go past TDC
        const dwellStartX =
          ((cycleDeg - scopeData.timing - dwellDeg) / cycleDeg) * w;

        // Draw ignition waveform
        if (scopeData.cut) {
          // Cut - show dashed line (no fire)
          scopeCtx2.strokeStyle = "#ff4444";
          scopeCtx2.setLineDash([8, 8]);
          scopeCtx2.lineWidth = 2;
          scopeCtx2.beginPath();
          scopeCtx2.moveTo(0, lowY);
          scopeCtx2.lineTo(w, lowY);
          scopeCtx2.stroke();
          scopeCtx2.setLineDash([]);

          // X mark at where fire would be
          scopeCtx2.strokeStyle = "#ff4444";
          scopeCtx2.lineWidth = 3;
          const xSize = 10;
          scopeCtx2.beginPath();
          scopeCtx2.moveTo(ignX - xSize, h / 2 - xSize);
          scopeCtx2.lineTo(ignX + xSize, h / 2 + xSize);
          scopeCtx2.moveTo(ignX + xSize, h / 2 - xSize);
          scopeCtx2.lineTo(ignX - xSize, h / 2 + xSize);
          scopeCtx2.stroke();
        } else {
          // Normal fire
          scopeCtx2.strokeStyle = "#00ffff";
          scopeCtx2.lineWidth = 2;
          scopeCtx2.beginPath();

          // Low before dwell
          scopeCtx2.moveTo(0, lowY);
          scopeCtx2.lineTo(Math.max(0, dwellStartX), lowY);

          // Dwell period (charging coil - high)
          scopeCtx2.lineTo(dwellStartX, highY);
          scopeCtx2.lineTo(ignX, highY);

          // Fire! (sharp spike down)
          scopeCtx2.lineTo(ignX, lowY + (lowY - highY) * 0.3); // Spike below baseline
          scopeCtx2.lineTo(ignX + pulseWidth, lowY);

          // Low after fire
          scopeCtx2.lineTo(w, lowY);
          scopeCtx2.stroke();

          // Fire point marker
          scopeCtx2.strokeStyle = "#00ffff";
          scopeCtx2.setLineDash([4, 4]);
          scopeCtx2.lineWidth = 1;
          scopeCtx2.beginPath();
          scopeCtx2.moveTo(ignX, 0);
          scopeCtx2.lineTo(ignX, h);
          scopeCtx2.stroke();
          scopeCtx2.setLineDash([]);
        }

        // TDC reference line (at x=0)
        scopeCtx2.strokeStyle = "#666";
        scopeCtx2.lineWidth = 1;
        scopeCtx2.beginPath();
        scopeCtx2.moveTo(1, 0);
        scopeCtx2.lineTo(1, h);
        scopeCtx2.stroke();

        // Draw stroke zone labels on both channels
        drawStrokeLabels(scopeCtx1, w, h, cycleDeg);
        drawStrokeLabels(scopeCtx2, w, h, cycleDeg);
      }

      function drawStrokeLabels(ctx, w, h, cycleDeg) {
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";

        if (cycleDeg === 360) {
          // 2-stroke: 2 zones
          // 0-180Â°: TENAGA+BUANG (Power+Exhaust)
          // 180-360Â°: ISAP+KOMPRESI (Intake+Compression)

          const halfX = w / 2;

          // Zone divider line at 180Â°
          ctx.strokeStyle = "#444";
          ctx.setLineDash([2, 2]);
          ctx.beginPath();
          ctx.moveTo(halfX, 0);
          ctx.lineTo(halfX, h);
          ctx.stroke();
          ctx.setLineDash([]);

          // Labels
          ctx.fillStyle = "#ff8844";
          ctx.fillText("TENAGA+BUANG", w * 0.25, 12);

          ctx.fillStyle = "#44ff88";
          ctx.fillText("ISAP+KOMPRESI", w * 0.75, 12);
        } else {
          // 4-stroke: 4 zones (720Â°)
          // 0-180Â°: TENAGA (Power)
          // 180-360Â°: BUANG (Exhaust)
          // 360-540Â°: ISAP (Intake)
          // 540-720Â°: KOMPRESI (Compression)

          const quarterX = w / 4;

          // Zone divider lines
          ctx.strokeStyle = "#444";
          ctx.setLineDash([2, 2]);
          for (let i = 1; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(quarterX * i, 0);
            ctx.lineTo(quarterX * i, h);
            ctx.stroke();
          }
          ctx.setLineDash([]);

          // Labels
          ctx.fillStyle = "#ff8844";
          ctx.fillText("TENAGA", quarterX * 0.5, 12);

          ctx.fillStyle = "#888888";
          ctx.fillText("BUANG", quarterX * 1.5, 12);

          ctx.fillStyle = "#44ff88";
          ctx.fillText("ISAP", quarterX * 2.5, 12);

          ctx.fillStyle = "#4488ff";
          ctx.fillText("KOMPRESI", quarterX * 3.5, 12);
        }
      }

      // ============================================================================
      // INIT
      // ============================================================================
      function initGraphs() {
        drawGraph("graphRpm", graphDataRpm, 0, 15000, "#00ff88", "");
        drawGraph("graphTemp", graphDataTemp, 0, 200, "#ff9100", "Â°C");
        drawGraph("graphBatt", graphDataBatt, 8, 16, "#00d4ff", "V");
        drawGraph("graphCharging", graphDataCharging, 8, 16, "#ffff00", "V");
        drawGraph("graphCpu", graphDataCpu, 0, 100, "#ff00ff", "%");
        drawGraph("graphRam", graphDataRam, 0, 100, "#00ffff", "%");
      }

      window.addEventListener("load", () => {
        initMapTable();
        initQsMapGrid();
        connect();
        setTimeout(drawMapCanvas, 200);
        setTimeout(initGraphs, 300);
      });

      window.addEventListener("resize", () => {
        if (document.getElementById("maps").classList.contains("active")) {
          drawMapCanvas();
          scopeCtx1 = null;
          scopeCtx2 = null;
          initScopeCanvas();
        }
        if (document.getElementById("dashboard").classList.contains("active")) {
          initGraphs();
        }
      });
    </script>
  </body>
</html>
